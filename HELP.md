# Getting Started

## * objects[万物皆对象] *
    * 创建一个 String 引用
        String s;
    * 创建一个引用的同时进行初始化
        String s = "asdf";
    * 创建一个新的对象实例，通常我们使用new操作符来创建一个新对象
        String s = new String("asdf");
    * 数据存储
        寄存器（Registers）最快的存储区域，位于 CPU 内部 ^2。
        栈内存（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。
        堆内存（Heap）这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。
        常量存储（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。
        非 RAM 存储（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。
    * 基本类型默认值
        boolean	    false
        char	    \u0000 (null)
        byte	    (byte) 0
        short	    (short) 0
        int	        0
        long	    0L
        float	    0.0f
        double	    0.0d
        通常来说，传递对象就意味者传递对象的引用。
        这些默认值仅在 Java 初始化类的时候才会被赋予。
    * 高精度数值
        在 Java 中有两种类型的数据可用于高精度的计算。它们是 BigInteger 和 BigDecimal。尽管它们大致可以划归为“包装类型”，但是它们并没有对应的基本类型。
            BigInteger 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。 
            BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的货币计算。
    * 数组的存储
        数组使用前需要被初始化，并且不能访问数组长度以外的数据。
        当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为 null 。在使用该数组之前，我们必须为每个引用指定一个对象 。如果我们尝试使用为 null 的引用，则会在运行时报错。
        创建基本类型的数组。编译器通过将该数组的内存全部置零来保证初始化。
        
## * operators[运算符] *
    * 优先级
        乘法和除法在加法和减法之前完成。
    * 赋值
        运算符的赋值是由符号 = 完成的。它代表着获取 = 右边的值并赋给左边的变量。
        右边可以是任何常量、变量或者可产生一个返回值的表达式。但左边必须是一个明确的、已命名的变量。
        基本类型的赋值都是直接的，而不像对象，赋予的只是其内存的引用。举个例子，a = b 
            如果 b 是基本类型，那么赋值操作会将 b 的值复制一份给变量 a， 此后若 a 的值发生改变是不会影响到 b 的。
            如果是为对象赋值，那么结果就不一样了。对一个对象进行操作时，我们实际上操作的是它的引用。所以我们将右边的对象赋予给左边时，赋予的只是该对象的引用。此时，两者指向的堆中的对象还是同一个。
    * 一元加减运算符
            一元减号可以得到数据的负值。一元加号的作用相反，不过它唯一能影响的就是把较小的数值类型自动转换为 int 类型。
    * 递增和递减
        “前递增”表示 ++(++a) 运算符位于变量或表达式的前面；会先执行递增/减运算，再返回值。
        “后递增”表示 ++(a++) 运算符位于变量的后面；会先返回值，再执行递增/减运算
    * 测试对象等价
        数值的比较可以用 == 或 != 进行
        Integer 比较
            用 == 或 != 进行
                1.内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，在这个范围内是直接返回数值
                2.[-128, 127] 范围外，可使用 Integer.intValue() 在比对
            用 equals
                [-128, 127] 范围之外
        equals() 的默认行为是比较对象的引用而非具体内容（即引用地址）。因此，除非你在新类中覆写 equals() 方法，否则我们将获取不到想要的结果。
    * 短路
        && 或 ||
            表达式走到 false 后，不会再继续往下走；返回 false
        & 或 | 
            表达式走到 false 后，会再继续往下走；返回 false
    * 字面值常量
        Long 型数值，结尾使用大写 L 或小写 l 皆可（不推荐使用 l，因为容易与阿拉伯数值 1 混淆）。
        float 浮点数，大写 F 或小写 f 表示 。
        double 双精度，大写 D 或小写 d 表示 。
        十六进制（以 16 为基数），适用于所有整型数据类型，由前导 0x 或 0X 表示，后跟 0-9 或 a-f （大写或小写）。
    * 位运算符
        与、或、异或、非 运算
        与【&】
            若两个输入位都是 1，运算结果是 1，否则结果是 0。
        或【|】
            若两个输入位里至少有一个是 1，运算结果是 1；只有在两个输入位都是 0 的情况下，运算结果才是 0。
        异或【^】
            若两个输入位的某一个是 1，另一个不是 1，运算结果才是 1。
        非【~】
            属于一元运算符；它只对一个自变量进行操作（其他所有运算符都是二元运算符）。
            按位非运算后结果与输入位相反。
            例如输入 0，则输出 1；输入 1，则输出 0。
        &=，|= 和 ^= 都是合法的（由于 ~ 是一元运算符，所以不可与 = 联合使用）。
        - 移位运算符
            高位代表符号：0 表示正，1 表示负。
            概念：移位运算符面向的运算对象也是二进制的“位”。它们只能用于处理整数类型（基本类型的一种）。
            分类
                左移位运算符 << 能将其左边的运算对象向左移动右侧指定的位数（在低位补 0）。
                右移位运算符 >> 则相反。右移位运算符有“正”、“负”值：若值为正，则在高位插入 0；若值为负，则在高位插入 1。
                “不分正负”的右移位运算符（>>>），它使用了“零扩展”（zero extension）：无论正负，都在高位插入 0。
            移位可以与等号 <<= 或 >>= 或 >>>= 组合使用。
    * 三元运算符
        布尔表达式 ? 值 1 : 值 2
        若表达式计算为 true，则返回结果 值 1 ；如果表达式的计算为 false，则返回结果 值 2。
    * 字符串运算符
        一个空字符串 "" 跟着一个基本类型的数据。这样可以隐式地将其转换为字符串。
    * 类型转换
        在适当的时候，Java 会将一种数据类型自动转换成另一种。
        要执行强制转换，需要将所需的数据类型放在任何值左侧的括号内，如下所示：long lng2 = (long)200;  
        向下转换（将容量较大的数据类型转换成容量较小的类型）
            必须显式地类型转换。
            可能会发生信息丢失的危险。
        向上转型  
            不必进行显式的类型转换，因为较大类型的数据肯定能容纳较小类型的数据，不会造成任何信息的丢失。
    * 截断和舍入
        从 float 和 double 转换为整数值时，小数位将被截断。
        若你想对结果进行四舍五入，可以使用 java.lang.Math 的 round() 方法
    * 类型提升
        如果我们对小于 int 的基本数据类型（即 char、byte 或 short）执行任何算术或按位操作，这些值会在执行操作之前类型提升为 int，并且结果值的类型为 int。
        若想重新使用较小的类型，必须使用强制转换（由于重新分配回一个较小的类型，结果可能会丢失精度）。
        通常，表达式中最大的数据类型是决定表达式结果的数据类型。float 型和 double 型相乘，结果是 double 型的；int 和 long 相加，结果是 long 型。
    
## * control[控制流] *
    * if-else
        if-else 语句是控制程序执行流程最基本的形式。 其中 else 是可选的，因此可以有两种形式的 if。
    * 迭代语句
        while，do-while 和 for 用来控制循环语句。只有控制循环的布尔表达式计算结果为 false，循环语句才会停止。
        while
            执行语句会在每一次循环前，判断布尔表达式返回值是否为 true。
        do-while 
            即使条件表达式返回结果为 false， do-while 语句也至少会执行一次。
        for
            该循环在第一次迭代之前执行初始化。随后，它会执行布尔表达式，并在每次迭代结束时，进行某种形式的步进。
        switch
            根据整数表达式的值，switch 语句可以从一系列代码中选出一段去执行。
            Java 7 增加了在字符串上 switch 的用法。
            若省略 break， 会继续执行后面的 case 语句的代码，直到遇到一个 break 为止。
    * return
        关键字包括 return，break，continue 和跳转到带标签语句的方法，类似于其他语言中的 goto。
    * break 和 continue
        break 表示跳出当前循环体。
        continue 表示停止本次循环，开始下一次循环。
        
        demo[com/mzl/control/LabeledFor.java]
        简单的一个 continue 会退回最内层循环的开头（顶部），并继续执行。
        带有标签的 continue 会到达标签的位置，并重新进入紧接在那个标签后面的循环。
        break 会中断当前循环，并移离当前标签的末尾。
        带标签的 break 会中断当前循环，并移离由那个标签指示的循环的末尾。
        
## * housekeeping[初始化和清理] *
    * 利用构造器保证初始化
        分类：
            无参构造器
            有参构造器
        在 Java 中，对象的创建与初始化是统一的概念，二者不可分割。
        在 Java 中，类的设计者通过构造器保证每个对象的初始化。
        构造器没有返回值，它是一种特殊的方法。
        如果一个类有构造器，那么 Java 会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化。
    * 方法重载
        区分重载方法
            每个被重载的方法必须有独一无二的参数列表。
        重载与基本类型
            基本类型可以自动从较小的类型转型为较大的类型。
            如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换，如果你不做的话，编译器就会报错。
        返回值的重载
            1.可以根据返回值进项判定调用的哪个方法
            2.如果只调用了方法，而不接收返回值，Java 编译器就不知道你想调用哪个方法，所以你不能根据返回值类型区分重载的方法。
    * 垃圾回收器:
        创建的对象不是通过 new 来分配内存的，而垃圾回收器只知道如何释放用 new 创建的对象的内存。为了处理这种情况，Java 允许在类中定义一个名为 finalize() 的方法。
        对象可能不被垃圾回收。
        垃圾回收不等同于析构。
        垃圾回收只与内存有关。
    * 垃圾回收器如何工作
        垃圾回收器通过重新排列对象，实现了一种高速的、有无限空间可分配的堆模型。
        引用计数
            每个对象中含有一个引用计数器，每当有引用指向该对象时，引用计数加 1。当引用离开作用域或被置为 null 时，引用计数减 1。
        停止-复制（stop-and-copy）
        标记-清扫（mark-and-sweep）
            对一般用途而言，"标记-清扫"方式速度相当慢，但是当你知道程序只会产生少量垃圾甚至不产生垃圾时，它的速度就很快了。
        类(class)要被使用必须经过装载，连接，初始化这样的过程。
            连接阶段又可以分为三个子步骤：验证、准备和解析。
                1. 验证就是要确保java类型数据格式 的正确性，并适于JVM使用。
                2. 准备阶段，JVM为静态变量分配内存空间，并设置默认值，注意，这里是设置默认值，比如说int型的变量会被赋予默认值0 。在这个阶段，JVM可能还会为一些数据结构分配内存，目的 是提高运行程序的性能，比如说方法表。
                3. 解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用。这个阶段可以被推迟到初始化之后，当程序运行的过程中真正使用某个符号引用的时候 再去解析它。
    * 静态数据的初始化
        无论创建多少个对象，静态数据都只占用一份存储区域
        static 关键字不能应用于局部变量，所以只能作用于属性（字段、域）
        如果在定义时进行初始化，那么静态变量看起来就跟非静态变量一样。
        静态初始化只有在必要时刻才会进行（类会在首次被“主动使用”时执行初始化，为类（静态）变量赋予正确的初始值）
        主动使用包括：
            1. 创建类的实例
            2. 调用类的静态方法
            3. 使用类的非常量静态字段
            4. 调用Java API中的某些反射方法
            5. 初始化某个类的子类
            6. 含有main()方法的类启动时
        初始化一个类包括两个步骤：
            1、 如果类存在直接父类的话，且直接父类还没有被初始化，则先初始化其直接父类
            2、 如果类存在一个初始化方法，就执行此方法
        java调用某个类的静态方法时不会执行构造方法，只有在实例化时才会调用构造方法
    * 数组初始化
        数组是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。
        所有的数组（无论是对象数组还是基本类型数组）都有一个固定成员 length，告诉你这个数组有多少个元素，你不能对其修改。
        数组元素中的基本数据类型值会自动初始化为默认值（对于数字和字符是 0；对于布尔型是 false）
    * 枚举类型
    
## * hiding[封装] *
    * 访问修饰符（access specifier）
        从“最大权限”到“最小权限”依次是：public，protected，包访问权限（package access）（没有关键字）和 private。
    * 包的概念
        包内包含一组类，它们被组织在一个单独的命名空间（namespace）下。
        将数据和方法包装进类中并把具体实现隐藏被称作是封装（encapsulation）。其结果就是一个同时带有特征和行为的数据类型。
    * 访问权限修饰符
        取得对成员的访问权的唯一方式是：
            使成员成为 public。那么无论是谁，无论在哪，都可以访问它。
            赋予成员默认包访问权限，不用加任何访问修饰符，然后将其他类放在相同的包内。这样，其他类就可以访问该成员。
            在"复用"这一章你将看到，继承的类既可以访问 public 成员，也可以访问 protected 成员（但不能访问 private 成员）。只有当两个类处于同一个包内，它才可以访问包访问权限的成员。但现在不用担心继承和 protected。
            提供访问器（accessor）和修改器（mutator）方法（有时也称为"get/set" 方法），从而读取和改变值。
        public: 接口访问权限
            当你使用关键字 public，就意味着紧随 public 后声明的成员对于每个人都是可用的，尤其是使用类库的客户端程序员更是如此。
        默认包
            Java 把这样的文件看作是隶属于该目录的默认包中，因此它们为该目录中所有的其他文件都提供了包访问权限。
        private: 你无法访问
            关键字 private 意味着除了包含该成员的类，其他任何类都无法访问这个成员。
        protected: 继承访问权限
            相同包内的其他类可以访问 protected 元素。
            关键字 protected 处理的是继承的概念，通过继承可以利用一个现有的类——我们称之为基类，然后添加新成员到现有类中而不必碰现有类。
            表示“就类的用户而言，这是 private 的。但对于任何继承它的子类或在同一包中的类，它是可访问的。”（protected 也提供了包访问权限）
    * 接口和实现
        访问控制通常被称为隐藏实现（implementation hiding）。
        将数据和方法包装进类中并把具体实现隐藏被称作是封装（encapsulation）。
        出于两个重要的原因，访问控制在数据类型内部划定了边界。
            第一个原因：确立客户端程序员可以使用和不能使用的边界。
                可以在结构中建立自己的内部机制而不必担心客户端程序员偶尔将内部实现作为他们可以使用的接口的一部分。
            第二个原因：将接口与实现分离。
                如果在一组程序中使用接口，而客户端程序员只能向 public 接口发送消息的话，那么就可以自由地修改任何不是 public 的事物（例如包访问权限，protected，或 private 修饰的事物），却不会破坏客户端代码。
    * 类访问权限
        每个编译单元（即每个文件）中只能有一个 public 类。这表示，每个编译单元有一个公共的接口用 public 类表示。该接口可以包含许多支持包访问权限的类。一旦一个编译单元中出现一个以上的 public 类，编译就会报错。
        public 类的名称必须与含有该编译单元的文件名相同，包括大小写。所以对于 Widget 来说，文件名必须是 Widget.java，不能是 widget.java 或 WIDGET.java。再次强调，如果名字不匹配，编译器会报错。
        虽然不是很常见，但是编译单元内没有 public 类也是可能的。这时可以随意命名文件（尽管随意命名会让代码的阅读者和维护者感到困惑）。
        
## * reuse[复用] *
    两种方式来达到这个目的：
        “组合”（Composition），在新类中创建现有类的对象。
        “继承”（Inheritance）,创建现有类类型的新类。继承是面向对象编程（OOP）的重要基础之一。更多功能相关将在多态（Polymorphism）章节中介绍。
    * 组合语法[com/mzl/reuse/SprinklerSystem.java,com/mzl/reuse/Bath.java]
        你仅需要把对象的引用（object references）放置在一个新的类里，这就使用了组合。
        初始化引用有四种方法:
            当对象被定义时。这意味着它们总是在调用构造函数之前初始化。
            在该类的构造函数中。
            在实际使用对象之前。这通常称为延迟初始化。在对象创建开销大且不需要每次都创建对象的情况下，它可以减少开销。
            使用实例初始化。
    * 继承语法
        继承是所有面向对象语言的一个组成部分。
        事实证明，在创建类时总是要继承，因为除非显式地继承其他类，否则就隐式地继承 Java 的标准根类对象（Object）。
        如果其他包中的类继承 Cleanser，则该类只能访问 Cleanser 的公共成员。
        为了允许继承，一般规则是所有字段为私有，所有方法为公共。(受保护成员也允许派生类访问;你以后会知道的。)
        Java的 super 关键字引用了当前类继承的“超类”(基类)。
        继承时，你不受限于使用基类的方法。你还可以像向类添加任何方法一样向派生类添加新方法:只需定义它。
    * 初始化基类
        基类（父类）和派生类（子类）
        Java 自动在派生类构造函数中插入对基类构造函数的调用。
        构造从基类“向外”进行，因此基类在派生类构造函数能够访问它之前进行初始化。
    * 委托[com/mzl/reuse/delegate]
        Java不直接支持的第三种重用关系称为委托。
        这介于继承和组合之间，因为你将一个成员对象放在正在构建的类中(比如组合)，但同时又在新类中公开来自成员对象的所有方法(比如继承)。
        类型：
            A use B
                B类对象在A类中出现，但是是以局部变量或是方法参数的形式出现的。A类中并没有B类的对象作为域。
                一般称这种delegation为临时性的delegation。
            A has B
                B类对象在A类中出现，B类的对象是A类的域之一。B类对象通过A类对象的constructor方法或其它方法从外部输入A类对象。
                有两种情况。
                    1）Association。A类对象和B类对象之间并没有从属关系。
                    2）Aggregation。A类对象由B类聚合而成，但是B类可以脱离A类单独存在。
                一般称这种delegation为永久性的delegation。
            A ispartof B
                B类对象在A类中出现，B类的对象是A类的域之一。B类对象在A类对象内创建。
                B类对象不能脱离A类对象独立存在。
                一般称这种delegation为永久性的delegation。
    * 聚合
    
    * 结合组合与继承
    
    * 组合与继承的选择
        组合和继承都允许在新类中放置子对象（组合是显式的，而继承是隐式的）。
        当你想在新类中包含一个已有类的功能时，使用组合，而非继承。
        如果必须向上转型，那么继承就是必要的，但如果不需要，则要进一步考虑是否该采用继承。
    * final关键字
        final 数据
            一个被 static 和 final 同时修饰的属性只会占用一段不能改变的存储空间。
            基本类型
                对于基本类型，final 使数值恒定不变。
            对象
                对于对象引用，final 使引用恒定不变。
                一旦引用被初始化指向了某个对象，它就不能改为指向其他对象。但是，对象本身是可以修改的，Java 没有提供将任意对象设为常量的方法。
        空白 final
            空白 final 指的是没有初始化值的 final 属性。
            你必须在定义时或在每个构造器中执行 final 变量的赋值操作。这保证了 final 属性在使用前已经被初始化过。
        final 参数
            在参数列表中，将参数声明为 final 意味着在方法中不能改变参数指向的对象或基本变量
        final 方法            
            原因有两个
                第一个原因是给方法上锁，防止子类通过覆写改变方法的行为。这是出于继承的考虑，确保方法的行为不会因继承而改变。
                效率。
            final 和 private
                类中所有的 private 方法都隐式地指定为 final。因为不能访问 private 方法，所以不能覆写它。
                可以给 private 方法添加 final 修饰，但是并不能给方法带来额外的含义。
        final 类
            当说一个类是 final （final 关键字在类定义之前），就意味着它不能被继承。
            由于 final 类禁止继承，类中所有的方法都被隐式地指定为 final，所以没有办法覆写它们。
        final 忠告
    * 类初始化和加载
        记住每个类的编译代码都存在于它自己独立的文件中。该文件只有在使用程序代码时才会被加载。
        一般可以说“类的代码在首次使用时加载“。这通常是指创建类的第一个对象，或者是访问了类的 static 属性或方法。
        构造器也是一个 static 方法尽管它的 static 关键字是隐式的。
        因此，准确地说，一个类当它任意一个 static 成员被访问时，就会被加载。
        首次使用时就是 static 初始化发生时。所有的 static 对象和 static 代码块在加载时按照文本的顺序（在类中定义的顺序）依次初始化。static 变量只被初始化一次。
            
## * polymorphism[多态] *
    多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做。
    封装通过合并特征和行为来创建新的数据类型。
    隐藏实现通过将细节私有化把接口与实现分离。
    而多态是消除类型之间的耦合。
    * 向上转型
        这种把一个对象引用当作它的基类引用的做法称为向上转型，因为继承图中基类一般都位于最上方。
    * 方法调用绑定
        概念：将一个方法调用和一个方法主体关联起来称作绑定。
            前期绑定：若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做前期绑定。
            后期绑定：意味着在运行时根据对象的类型进行绑定，也称为动态绑定或运行时绑定。
        Java 中除了 static 和 final 方法（private 方法也是隐式的 final）外，其他所有方法都是后期绑定。
        如果一个方法是静态(static)的，它的行为就不具有多态性。
        静态的方法只与类关联，与单个的对象无关。
    * 构造器和多态
        尽管构造器不具有多态性（事实上人们会把它看作是隐式声明的静态方法），但是理解构造器在复杂层次结构中运作多态还是非常重要的。
        初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用到。
        对象的构造器调用顺序如下：
            1.基类构造器被调用。这个步骤被递归地重复，这样一来类层次的顶级父类会被最先构造，然后是它的派生类，以此类推，直到最底层的派生类。
            2.按声明顺序初始化成员。
            3.调用派生类构造器的方法体。
        编写构造器有一条良好规范：
            做尽量少的事让对象进入良好状态。
                如果有可能的话，尽量不要调用类中的任何方法。
                在基类的构造器中能安全调用的只有基类的 final 方法（这也适用于可被看作是 final 的 private 方法）。
                这些方法不能被重写，因此不会产生意想不到的结果。你可能无法永远遵循这条规范，但应该朝着它努力。
    * 继承和清理
        在使用组合和继承创建新类时，大部分时候你无需关心清理。子对象通常会留给垃圾收集器处理。
        如果你存在清理问题，那么必须用心地为新类创建一个 dispose() 方法（这里用的是我选择的名称，你可以使用更好的名称）。
        由于继承，如果有其他特殊的清理工作的话，就必须在派生类中重写 dispose() 方法。当重写 dispose() 方法时，记得调用基类的 dispose() 方法，否则基类的清理工作不会发生
    * 使用继承设计
        学习过多态之后，一切看似都可以被继承，因为多态是如此巧妙的工具。这会给设计带来负担。事实上，如果利用已有类创建新类首先选择继承的话，事情会变得莫名的复杂。
        更好的方法是首先选择组合，特别是不知道该使用哪种方法时。
        组合不会强制设计是继承层次结构，而且组合更加灵活，因为可以动态地选择类型（因而选择相应的行为），而继承要求必须在编译时知道确切类型。
    * 替代 vs 扩展
        “is - a"关系：它有着相同的基本接口，纯粹的替代。
        “is - like - a” 关系：它有着相同的基本接口，但还具有需要额外方法实现的其他特性。
    * 向下转型与运行时类型信息
        由于向上转型（在继承层次中向上移动）会丢失具体的类型信息，那么为了重新获取类型信息，就需要在继承层次中向下移动，使用向下转型。
        
## * interfaces[接口] *
    接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。
    对于构建具有属性和未实现方法的类来说，抽象类也是重要且必要的工具。你不可能总是使用纯粹的接口。
    * 抽象类和方法
        抽象类，一种介于普通类和接口之间的折中手段。
        创建一个抽象类是为了通过通用接口操纵一系列类。 
        抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。
        创建抽象类和抽象方法是有帮助的，因为它们使得类的抽象性很明确，并能告知用户和编译器使用意图。
        抽象类同时也是一种有用的重构工具，使用它们使得我们很容易地将沿着继承层级结构上移公共方法。
        抽象类和普通类的主要有三点区别：
            1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。
            2）抽象类不能用来创建对象；
            3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。
    * 接口创建
        使用 interface 关键字创建接口。
        接口只提供形式，通常来说没有实现，尽管在某些受限制的情况下可以有实现。
        区别：
            Java 8之前
                只允许抽象方法，没有提供任何实现。
            Java 8
                允许接口包含默认方法和静态方法。
        接口同样可以包含属性，这些属性被隐式指明为 static 和 final。
        来自接口中的方法必须被定义为 public。否则，它们只有包访问权限，这样在继承时，它们的可访问权限就被降低了，这是 Java 编译器所不允许的。
        - 默认方法
            Java 8 为关键字 default 增加了一个新的用途（之前只用于 switch 语句和注解中）。
            当在接口中使用它时，任何实现接口却没有定义方法的时候可以使用 default 创建的方法体。
            默认方法，实现类没有实现它，不受影响，而且实现类还可以调用默认方法
    * 多继承
        多继承意味着一个类可能从多个父类型中继承特征和特性。
        Java 8，Java 通过默认方法具有了某种多继承的特性。
        属性仍然只会来自单个基类或抽象类，不会存在状态的多继承。
        实现多个接口时，若方法名，参数都一致，则实现时需要覆写该方法，否则会报错
    * 接口中的静态方法
        Java 8 允许在接口中添加静态方法。这么做能恰当地把工具功能置于接口中，从而操作接口，或者成为通用的工具
    * 抽象类和接口
尤其是在 Java 8 引入 default 方法之后，选择用抽象类还是用接口变得更加令人困惑。下表做了明确的区分：
        
| 特性 | 接口 | 抽象类 |
| ------ | ------ |------ |
| 组合 | 新类可以组合多个接口 |只能继承单一抽象类 |
| 状态 | 不能包含属性（除了静态属性，不支持对象状态） |可以包含属性，非抽象方法可能引用这些属性 |
| 默认方法和抽象方法 | 不需要在子类中实现默认方法。默认方法可以引用其他接口的方法 |必须在子类中实现抽象方法 |
| 构造器 | 没有构造器 |可以有构造器 |     
| 可见性 | 隐式 public |可以是 protected 或友元 |     
        
        有一条实际经验：尽可能地抽象。因此，更倾向使用接口而不是抽象类。只有当必要时才使用抽象类。除非必须使用，否则不要用接口和抽象类。大多数时候，普通类已经做得很好，如果不行的话，再移动到接口或抽象类中。
    * 完全解耦       
   
   
## [内部类]

## [集合]

## [函数式编程]

## [流式编程]

## [异常]

## [代码校验]

## [文件]

## [字符串]

## [类型信息]

## [泛型]

## [数组]

## [枚举]

## [注解]

## [并发编程]

## [设计模式]

## [jvm命令]
    aload 负载
        运作方式：加载本地变量的引用
        格式：aload index
        形式：aload = 25 (0x19)
        描述：
            该指数是一个无符号字节,必须被索引到当前帧的局部变量数组(§2.6)。局部变量的指数必须包含一个参考。objectref在局部变量指数推到操作数堆栈。
        笔记：
            aload指令不能用于加载一个类型的值returnAddress从一个局部变量到操作数堆栈。这种不对称的astore指令(§astore)是故意的。
            可以使用aload操作码结合宽指令(§宽)来访问一个本地变量使用两字节无符号索引。
    aload_<n>  
        运作方式：加载本地变量的引用
        格式：aload_<n>
        形式：
            aload_0 = 42 (0x2a)
            aload_1 = 43 (0x2b)
            aload_2 = 44 (0x2c)
            aload_3 = 45 (0x2d)
        描述：
            < n >必须被索引到当前帧的局部变量数组(§2.6)。在< n >局部变量必须包含一个参考。局部变量在< n >中的objectref推到操作数堆栈。
        笔记:
            一个aload_ < n >指令不能用于加载一个类型的值returnAddress从一个局部变量到操作数堆栈。这种不对称与相应astore_ < n >指令(§astore_ < n >)是故意的。
            每个aload_ < n >指令一样aload指数< n >,除了操作数< n >是隐式的。
    iload 加载
        运作方式：int从局部变量 加载
        格式：
            iload
            index
        形式：iload = 21（0x15）
        描述：
            该指数是一个必须是一个指数到当前帧（的局部变量阵列的无符号字节§2.6）。索引处的局部变量必须包含int。的值在局部变量的索引被压入操作数栈。
        笔记：
            所述ILOAD操作码可结合使用与宽 指令（§宽），使用两字节的无符号索引来访问的本地变量。
    iload_<n>
        运作方式：int从局部变量 加载
        格式：
            iload_<n>
        形式：
            iload_0 = 26（0x1a）
            iload_1 = 27（0x1b）
            iload_2 = 28（0x1c）
            iload_3 = 29（0x1d）
        描述：
            必须是当前帧的局部变量数组的索引（第2.6节）的局部变量必须包含一个int。的值在局部变量的被压入操作数栈。
        笔记：
            每个iload_<n>指令一样iload指数,除了操作数是隐式的。
    iconst 
        运作方式：推int常数
        格式：iconst_ <i>
        形式：
            iconst_m1 = 2（0x2）
            iconst_0 = 3（0x3）
            iconst_1 = 4（0x4）
            iconst_2 = 5（0x5）
            iconst_3 = 6（0x6）
            iconst_4 = 7（0x7）
            iconst_5 = 8（0x8）
        描述：
            将int常数（-1、0、1、2、3、4或5）推入操作数堆栈。
        笔记：
            这个家庭每个人的指令相当于bipush 的各自的价值,除了操作数是隐式的。
    putfield 
        运作方式：在对象中设置字段
        格式：
            putfield
            indexbyte1
            indexbyte2
        形式：putfield = 181（0xB5执行）
        描述：
        
    invokespecial 特殊调用
        运作方式：调用实例方法；对超类，私有和实例初始化方法调用的特殊处理
        格式：
            invokespecial
            indexbyte1
            indexbyte2
        形式：
            invokespecial = 183（0xb7）
        
## Java8 新增了非常多的特性，我们主要讨论以下几个：
    
    Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。
    
    方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
    
    默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。
    
    新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。
    
    Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。
    
    Date Time API − 加强对日期与时间的处理。
    
    Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。
    
    Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。