# Getting Started

## objects[万物皆对象]
    通常除了前面提到的“特殊”数据类型 boolean、 char、 byte、 short、 int、 long、 float 和 double。通常来说，传递对象就意味者传递对象的引用。
    
    * 创建一个 String 引用
        String s;
    * 创建一个引用的同时进行初始化
        String s = "asdf";
    * 创建一个新的对象实例，通常我们使用new操作符来创建一个新对象
        String s = new String("asdf");
    * 数据存储
        寄存器（Registers）最快的存储区域，位于 CPU 内部 ^2。
        栈内存（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。
        堆内存（Heap）这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。
        常量存储（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。
        非 RAM 存储（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。
    * 基本类型默认值
        boolean	    false
        char	    \u0000 (null)
        byte	    (byte) 0
        short	    (short) 0
        int	        0
        long	    0L
        float	    0.0f
        double	    0.0d
        
        这些默认值仅在 Java 初始化类的时候才会被赋予。
    * 高精度数值
        在 Java 中有两种类型的数据可用于高精度的计算。它们是 BigInteger 和 BigDecimal。尽管它们大致可以划归为“包装类型”，但是它们并没有对应的基本类型。
            BigInteger 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。 
            BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的货币计算。
    * 数组的存储
        数组使用前需要被初始化，并且不能访问数组长度以外的数据。
        当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为 null 。在使用该数组之前，我们必须为每个引用指定一个对象 。如果我们尝试使用为 null 的引用，则会在运行时报错。
        创建基本类型的数组。编译器通过将该数组的内存全部置零来保证初始化。
        
## operators[运算符]
    * 优先级
        乘法和除法在加法和减法之前完成。
    * 赋值
        运算符的赋值是由符号 = 完成的。它代表着获取 = 右边的值并赋给左边的变量。
        右边可以是任何常量、变量或者可产生一个返回值的表达式。但左边必须是一个明确的、已命名的变量。
        基本类型的赋值都是直接的，而不像对象，赋予的只是其内存的引用。举个例子，a = b 
            如果 b 是基本类型，那么赋值操作会将 b 的值复制一份给变量 a， 此后若 a 的值发生改变是不会影响到 b 的。
            如果是为对象赋值，那么结果就不一样了。对一个对象进行操作时，我们实际上操作的是它的引用。所以我们将右边的对象赋予给左边时，赋予的只是该对象的引用。此时，两者指向的堆中的对象还是同一个。
    * 一元加减运算符
            一元减号可以得到数据的负值。一元加号的作用相反，不过它唯一能影响的就是把较小的数值类型自动转换为 int 类型。
    * 递增和递减
        “前递增”表示 ++(++a) 运算符位于变量或表达式的前面；会先执行递增/减运算，再返回值。
        “后递增”表示 ++(a++) 运算符位于变量的后面；会先返回值，再执行递增/减运算
    * 测试对象等价
        数值的比较可以用 == 或 != 进行
        Integer 比较
            用 == 或 != 进行
                1.内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，在这个范围内是直接返回数值
                2.[-128, 127] 范围外，可使用 Integer.intValue() 在比对
            用 equals
                [-128, 127] 范围之外
        equals() 的默认行为是比较对象的引用而非具体内容（即引用地址）。因此，除非你在新类中覆写 equals() 方法，否则我们将获取不到想要的结果。
    * 短路
        && 或 ||
            表达式走到 false 后，不会再继续往下走；返回 false
        & 或 | 
            表达式走到 false 后，会再继续往下走；返回 false
    * 字面值常量
        对于 Long 型数值，结尾使用大写 L 或小写 l 皆可（不推荐使用 l，因为容易与阿拉伯数值 1 混淆）。
        大写 F 或小写 f 表示 float 浮点数。
        大写 D 或小写 d 表示 double 双精度。
        十六进制（以 16 为基数），适用于所有整型数据类型，由前导 0x 或 0X 表示，后跟 0-9 或 a-f （大写或小写）。
    * 位运算符
        与、或、异或、非 运算
        与【&】
            若两个输入位都是 1，运算结果是 1，否则结果是 0。
        或【|】
            若两个输入位里至少有一个是 1，运算结果是 1；只有在两个输入位都是 0 的情况下，运算结果才是 0。
        异或【^】
            若两个输入位的某一个是 1，另一个不是 1，运算结果才是 1。
        非【~】
            属于一元运算符；它只对一个自变量进行操作（其他所有运算符都是二元运算符）。
            按位非运算后结果与输入位相反。
            例如输入 0，则输出 1；输入 1，则输出 0。
        &=，|= 和 ^= 都是合法的（由于 ~ 是一元运算符，所以不可与 = 联合使用）。
        - 移位运算符
            高位代表符号：0 表示正，1 表示负。
            概念：移位运算符面向的运算对象也是二进制的“位”。它们只能用于处理整数类型（基本类型的一种）。
            分类
                左移位运算符 << 能将其左边的运算对象向左移动右侧指定的位数（在低位补 0）。
                右移位运算符 >> 则相反。右移位运算符有“正”、“负”值：若值为正，则在高位插入 0；若值为负，则在高位插入 1。
                “不分正负”的右移位运算符（>>>），它使用了“零扩展”（zero extension）：无论正负，都在高位插入 0。
            移位可以与等号 <<= 或 >>= 或 >>>= 组合使用。
    * 三元运算符
        布尔表达式 ? 值 1 : 值 2
        若表达式计算为 true，则返回结果 值 1 ；如果表达式的计算为 false，则返回结果 值 2。
    * 字符串运算符
        一个空字符串 "" 跟着一个基本类型的数据。这样可以隐式地将其转换为字符串。
    * 类型转换
        在适当的时候，Java 会将一种数据类型自动转换成另一种。
        要执行强制转换，需要将所需的数据类型放在任何值左侧的括号内，如下所示：long lng2 = (long)200;  
        向下转换（将容量较大的数据类型转换成容量较小的类型）
            必须显式地类型转换。
            可能会发生信息丢失的危险。
        向上转型  
            不必进行显式的类型转换，因为较大类型的数据肯定能容纳较小类型的数据，不会造成任何信息的丢失。
    * 截断和舍入
        从 float 和 double 转换为整数值时，小数位将被截断。
        若你想对结果进行四舍五入，可以使用 java.lang.Math 的 round() 方法
    * 类型提升
        如果我们对小于 int 的基本数据类型（即 char、byte 或 short）执行任何算术或按位操作，这些值会在执行操作之前类型提升为 int，并且结果值的类型为 int。
        若想重新使用较小的类型，必须使用强制转换（由于重新分配回一个较小的类型，结果可能会丢失精度）。
        通常，表达式中最大的数据类型是决定表达式结果的数据类型。float 型和 double 型相乘，结果是 double 型的；int 和 long 相加，结果是 long 型。
    
## control[控制流]

## housekeeping[初始化和清理]
    垃圾回收器:
        对象可能不被垃圾回收。
        垃圾回收不等同于析构。
        垃圾回收只与内存有关。
    垃圾回收机制
        引用计数
        停止-复制（stop-and-copy）
        标记-清扫（mark-and-sweep）
            对一般用途而言，"标记-清扫"方式速度相当慢，但是当你知道程序只会产生少量垃圾甚至不产生垃圾时，它的速度就很快了。
    类(class)要被使用必须经过装载，连接，初始化这样的过程。
        连接阶段又可以分为三个子步骤：验证、准备和解析。
            1. 验证就是要确保java类型数据格式 的正确性，并适于JVM使用。
            2. 准备阶段，JVM为静态变量分配内存空间，并设置默认值，注意，这里是设置默认值，比如说int型的变量会被赋予默认值0 。在这个阶段，JVM可能还会为一些数据结构分配内存，目的 是提高运行程序的性能，比如说方法表。
            3. 解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用。这个阶段可以被推迟到初始化之后，当程序运行的过程中真正使用某个符号引用的时候 再去解析它。
    
    无论创建多少个对象，静态数据都只占用一份存储区域
    static 关键字不能应用于局部变量，所以只能作用于属性（字段、域）
    静态初始化只有在必要时刻才会进行（类会在首次被“主动使用”时执行初始化，为类（静态）变量赋予正确的初始值）
        主动使用包括：
            1. 创建类的实例
            2. 调用类的静态方法
            3. 使用类的非常量静态字段
            4. 调用Java API中的某些反射方法
            5. 初始化某个类的子类
            6. 含有main()方法的类启动时
        初始化一个类包括两个步骤：
            1、 如果类存在直接父类的话，且直接父类还没有被初始化，则先初始化其直接父类
            2、 如果类存在一个初始化方法，就执行此方法
    java调用某个类的静态方法时不会执行构造方法，只有在实例化时才会调用构造方法
    数组
        所有的数组（无论是对象数组还是基本类型数组）都有一个固定成员 length，告诉你这个数组有多少个元素，你不能对其修改。
        数组元素中的基本数据类型值会自动初始化为默认值（对于数字和字符是 0；对于布尔型是 false）
        
## hiding[封装]
    本章讨论了类库是如何通过类构建的：首先，介绍了将一组类打包到类库的方式，其次介绍了类如何控制对其成员的访问。
    包内包含一组类，它们被组织在一个单独的命名空间（namespace）下。
    包访问权限
        使成员成为 public。那么无论是谁，无论在哪，都可以访问它。
        赋予成员默认包访问权限，不用加任何访问修饰符，然后将其他类放在相同的包内。这样，其他类就可以访问该成员。
        在"复用"这一章你将看到，继承的类既可以访问 public 成员，也可以访问 protected 成员（但不能访问 private 成员）。只有当两个类处于同一个包内，它才可以访问包访问权限的成员。但现在不用担心继承和 protected。
        提供访问器（accessor）和修改器（mutator）方法（有时也称为"get/set" 方法），从而读取和改变值。
    将数据和方法包装进类中并把具体实现隐藏被称作是封装（encapsulation）。其结果就是一个同时带有特征和行为的数据类型。
    类访问权限
        每个编译单元（即每个文件）中只能有一个 public 类。这表示，每个编译单元有一个公共的接口用 public 类表示。该接口可以包含许多支持包访问权限的类。一旦一个编译单元中出现一个以上的 public 类，编译就会报错。
        public 类的名称必须与含有该编译单元的文件名相同，包括大小写。所以对于 Widget 来说，文件名必须是 Widget.java，不能是 widget.java 或 WIDGET.java。再次强调，如果名字不匹配，编译器会报错。
        虽然不是很常见，但是编译单元内没有 public 类也是可能的。这时可以随意命名文件（尽管随意命名会让代码的阅读者和维护者感到困惑）。
        
## reuse[复用]
    在本章里，你将学习到两种方式来达到这个目的：
        第一种方式直接了当。在新类中创建现有类的对象。这种方式叫做“组合”（Composition），通过这种方式复用代码的功能，而非其形式。
        第二种方式更为微妙。创建现有类类型的新类。照字面理解：采用现有类形式，又无需在编码时改动其代码，这种方式就叫做“继承”（Inheritance），编译器会做大部分的工作。继承是面向对象编程（OOP）的重要基础之一。更多功能相关将在多态（Polymorphism）章节中介绍。
    组合语法
        你仅需要把对象的引用（object references）放置在一个新的类里，这就使用了组合。
        初始化引用有四种方法:
            当对象被定义时。这意味着它们总是在调用构造函数之前初始化。
            在该类的构造函数中。
            在实际使用对象之前。这通常称为延迟初始化。在对象创建开销大且不需要每次都创建对象的情况下，它可以减少开销。
            使用实例初始化。
    继承语法
        继承是所有面向对象语言的一个组成部分。
        事实证明，在创建类时总是要继承，因为除非显式地继承其他类，否则就隐式地继承 Java 的标准根类对象（Object）。
        
## [多态]

## [接口]

## [内部类]

## [集合]

## [函数式编程]

## [流式编程]

## [异常]

## [代码校验]

## [文件]

## [字符串]

## [类型信息]

## [泛型]

## [数组]

## [枚举]

## [注解]

## [并发编程]

## [设计模式]

Java8 新增了非常多的特性，我们主要讨论以下几个：
    
    Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。
    
    方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
    
    默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。
    
    新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。
    
    Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。
    
    Date Time API − 加强对日期与时间的处理。
    
    Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。
    
    Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。