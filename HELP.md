# Getting Started

## * objects[万物皆对象] *
    * 创建一个 String 引用
        String s;
    * 创建一个引用的同时进行初始化
        String s = "asdf";
    * 创建一个新的对象实例，通常我们使用new操作符来创建一个新对象
        String s = new String("asdf");
    * 数据存储
        寄存器（Registers）最快的存储区域，位于 CPU 内部 ^2。
        栈内存（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。
        堆内存（Heap）这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。
        常量存储（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。
        非 RAM 存储（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。
    * 基本类型默认值
        boolean	    false
        char	    \u0000 (null)
        byte	    (byte) 0
        short	    (short) 0
        int	        0
        long	    0L
        float	    0.0f
        double	    0.0d
        通常来说，传递对象就意味者传递对象的引用。
        这些默认值仅在 Java 初始化类的时候才会被赋予。
    * 高精度数值
        在 Java 中有两种类型的数据可用于高精度的计算。它们是 BigInteger 和 BigDecimal。尽管它们大致可以划归为“包装类型”，但是它们并没有对应的基本类型。
            BigInteger 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。 
            BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的货币计算。
    * 数组的存储
        数组使用前需要被初始化，并且不能访问数组长度以外的数据。
        当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为 null 。在使用该数组之前，我们必须为每个引用指定一个对象 。如果我们尝试使用为 null 的引用，则会在运行时报错。
        创建基本类型的数组。编译器通过将该数组的内存全部置零来保证初始化。
        
## * operators[运算符] *
    * 优先级
        乘法和除法在加法和减法之前完成。
    * 赋值
        运算符的赋值是由符号 = 完成的。它代表着获取 = 右边的值并赋给左边的变量。
        右边可以是任何常量、变量或者可产生一个返回值的表达式。但左边必须是一个明确的、已命名的变量。
        基本类型的赋值都是直接的，而不像对象，赋予的只是其内存的引用。举个例子，a = b 
            如果 b 是基本类型，那么赋值操作会将 b 的值复制一份给变量 a， 此后若 a 的值发生改变是不会影响到 b 的。
            如果是为对象赋值，那么结果就不一样了。对一个对象进行操作时，我们实际上操作的是它的引用。所以我们将右边的对象赋予给左边时，赋予的只是该对象的引用。此时，两者指向的堆中的对象还是同一个。
    * 一元加减运算符
            一元减号可以得到数据的负值。一元加号的作用相反，不过它唯一能影响的就是把较小的数值类型自动转换为 int 类型。
    * 递增和递减
        “前递增”表示 ++(++a) 运算符位于变量或表达式的前面；会先执行递增/减运算，再返回值。
        “后递增”表示 ++(a++) 运算符位于变量的后面；会先返回值，再执行递增/减运算
    * 测试对象等价
        数值的比较可以用 == 或 != 进行
        Integer 比较
            用 == 或 != 进行
                1.内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，在这个范围内是直接返回数值
                2.[-128, 127] 范围外，可使用 Integer.intValue() 在比对
            用 equals
                [-128, 127] 范围之外
        equals() 的默认行为是比较对象的引用而非具体内容（即引用地址）。因此，除非你在新类中覆写 equals() 方法，否则我们将获取不到想要的结果。
    * 短路
        && 或 ||
            表达式走到 false 后，不会再继续往下走；返回 false
        & 或 | 
            表达式走到 false 后，会再继续往下走；返回 false
    * 字面值常量
        Long 型数值，结尾使用大写 L 或小写 l 皆可（不推荐使用 l，因为容易与阿拉伯数值 1 混淆）。
        float 浮点数，大写 F 或小写 f 表示 。
        double 双精度，大写 D 或小写 d 表示 。
        十六进制（以 16 为基数），适用于所有整型数据类型，由前导 0x 或 0X 表示，后跟 0-9 或 a-f （大写或小写）。
    * 位运算符
        与、或、异或、非 运算
        与【&】
            若两个输入位都是 1，运算结果是 1，否则结果是 0。
        或【|】
            若两个输入位里至少有一个是 1，运算结果是 1；只有在两个输入位都是 0 的情况下，运算结果才是 0。
        异或【^】
            若两个输入位的某一个是 1，另一个不是 1，运算结果才是 1。
        非【~】
            属于一元运算符；它只对一个自变量进行操作（其他所有运算符都是二元运算符）。
            按位非运算后结果与输入位相反。
            例如输入 0，则输出 1；输入 1，则输出 0。
        &=，|= 和 ^= 都是合法的（由于 ~ 是一元运算符，所以不可与 = 联合使用）。
        - 移位运算符
            高位代表符号：0 表示正，1 表示负。
            概念：移位运算符面向的运算对象也是二进制的“位”。它们只能用于处理整数类型（基本类型的一种）。
            分类
                左移位运算符 << 能将其左边的运算对象向左移动右侧指定的位数（在低位补 0）。
                右移位运算符 >> 则相反。右移位运算符有“正”、“负”值：若值为正，则在高位插入 0；若值为负，则在高位插入 1。
                “不分正负”的右移位运算符（>>>），它使用了“零扩展”（zero extension）：无论正负，都在高位插入 0。
            移位可以与等号 <<= 或 >>= 或 >>>= 组合使用。
    * 三元运算符
        布尔表达式 ? 值 1 : 值 2
        若表达式计算为 true，则返回结果 值 1 ；如果表达式的计算为 false，则返回结果 值 2。
    * 字符串运算符
        一个空字符串 "" 跟着一个基本类型的数据。这样可以隐式地将其转换为字符串。
    * 类型转换
        在适当的时候，Java 会将一种数据类型自动转换成另一种。
        要执行强制转换，需要将所需的数据类型放在任何值左侧的括号内，如下所示：long lng2 = (long)200;  
        向下转换（将容量较大的数据类型转换成容量较小的类型）
            必须显式地类型转换。
            可能会发生信息丢失的危险。
        向上转型  
            不必进行显式的类型转换，因为较大类型的数据肯定能容纳较小类型的数据，不会造成任何信息的丢失。
    * 截断和舍入
        从 float 和 double 转换为整数值时，小数位将被截断。
        若你想对结果进行四舍五入，可以使用 java.lang.Math 的 round() 方法
    * 类型提升
        如果我们对小于 int 的基本数据类型（即 char、byte 或 short）执行任何算术或按位操作，这些值会在执行操作之前类型提升为 int，并且结果值的类型为 int。
        若想重新使用较小的类型，必须使用强制转换（由于重新分配回一个较小的类型，结果可能会丢失精度）。
        通常，表达式中最大的数据类型是决定表达式结果的数据类型。float 型和 double 型相乘，结果是 double 型的；int 和 long 相加，结果是 long 型。
    
## * control[控制流] *
    * if-else
        if-else 语句是控制程序执行流程最基本的形式。 其中 else 是可选的，因此可以有两种形式的 if。
    * 迭代语句
        while，do-while 和 for 用来控制循环语句。只有控制循环的布尔表达式计算结果为 false，循环语句才会停止。
        while
            执行语句会在每一次循环前，判断布尔表达式返回值是否为 true。
        do-while 
            即使条件表达式返回结果为 false， do-while 语句也至少会执行一次。
        for
            该循环在第一次迭代之前执行初始化。随后，它会执行布尔表达式，并在每次迭代结束时，进行某种形式的步进。
        switch
            根据整数表达式的值，switch 语句可以从一系列代码中选出一段去执行。
            Java 7 增加了在字符串上 switch 的用法。
            若省略 break， 会继续执行后面的 case 语句的代码，直到遇到一个 break 为止。
    * return
        关键字包括 return，break，continue 和跳转到带标签语句的方法，类似于其他语言中的 goto。
    * break 和 continue
        break 表示跳出当前循环体。
        continue 表示停止本次循环，开始下一次循环。
        
        demo[com/mzl/control/LabeledFor.java]
        简单的一个 continue 会退回最内层循环的开头（顶部），并继续执行。
        带有标签的 continue 会到达标签的位置，并重新进入紧接在那个标签后面的循环。
        break 会中断当前循环，并移离当前标签的末尾。
        带标签的 break 会中断当前循环，并移离由那个标签指示的循环的末尾。
        
## * housekeeping[初始化和清理] *
    * 利用构造器保证初始化
        分类：
            无参构造器
            有参构造器
        在 Java 中，对象的创建与初始化是统一的概念，二者不可分割。
        在 Java 中，类的设计者通过构造器保证每个对象的初始化。
        构造器没有返回值，它是一种特殊的方法。
        如果一个类有构造器，那么 Java 会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化。
    * 方法重载
        区分重载方法
            每个被重载的方法必须有独一无二的参数列表。
        重载与基本类型
            基本类型可以自动从较小的类型转型为较大的类型。
            如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换，如果你不做的话，编译器就会报错。
        返回值的重载
            1.可以根据返回值进项判定调用的哪个方法
            2.如果只调用了方法，而不接收返回值，Java 编译器就不知道你想调用哪个方法，所以你不能根据返回值类型区分重载的方法。
    * 垃圾回收器:
        创建的对象不是通过 new 来分配内存的，而垃圾回收器只知道如何释放用 new 创建的对象的内存。为了处理这种情况，Java 允许在类中定义一个名为 finalize() 的方法。
        对象可能不被垃圾回收。
        垃圾回收不等同于析构。
        垃圾回收只与内存有关。
    * 垃圾回收器如何工作
        垃圾回收器通过重新排列对象，实现了一种高速的、有无限空间可分配的堆模型。
        引用计数
            每个对象中含有一个引用计数器，每当有引用指向该对象时，引用计数加 1。当引用离开作用域或被置为 null 时，引用计数减 1。
        停止-复制（stop-and-copy）
        标记-清扫（mark-and-sweep）
            对一般用途而言，"标记-清扫"方式速度相当慢，但是当你知道程序只会产生少量垃圾甚至不产生垃圾时，它的速度就很快了。
        类(class)要被使用必须经过装载，连接，初始化这样的过程。
            连接阶段又可以分为三个子步骤：验证、准备和解析。
                1. 验证就是要确保java类型数据格式 的正确性，并适于JVM使用。
                2. 准备阶段，JVM为静态变量分配内存空间，并设置默认值，注意，这里是设置默认值，比如说int型的变量会被赋予默认值0 。在这个阶段，JVM可能还会为一些数据结构分配内存，目的 是提高运行程序的性能，比如说方法表。
                3. 解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用。这个阶段可以被推迟到初始化之后，当程序运行的过程中真正使用某个符号引用的时候 再去解析它。
    * 静态数据的初始化
        无论创建多少个对象，静态数据都只占用一份存储区域
        static 关键字不能应用于局部变量，所以只能作用于属性（字段、域）
        如果在定义时进行初始化，那么静态变量看起来就跟非静态变量一样。
        静态初始化只有在必要时刻才会进行（类会在首次被“主动使用”时执行初始化，为类（静态）变量赋予正确的初始值）
        主动使用包括：
            1. 创建类的实例
            2. 调用类的静态方法
            3. 使用类的非常量静态字段
            4. 调用Java API中的某些反射方法
            5. 初始化某个类的子类
            6. 含有main()方法的类启动时
        初始化一个类包括两个步骤：
            1、 如果类存在直接父类的话，且直接父类还没有被初始化，则先初始化其直接父类
            2、 如果类存在一个初始化方法，就执行此方法
        java调用某个类的静态方法时不会执行构造方法，只有在实例化时才会调用构造方法
    * 数组初始化
        数组是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。
        所有的数组（无论是对象数组还是基本类型数组）都有一个固定成员 length，告诉你这个数组有多少个元素，你不能对其修改。
        数组元素中的基本数据类型值会自动初始化为默认值（对于数字和字符是 0；对于布尔型是 false）
    * 枚举类型
    
## * hiding[封装] *
    * 访问修饰符（access specifier）
        从“最大权限”到“最小权限”依次是：public，protected，包访问权限（package access）（没有关键字）和 private。
    * 包的概念
        包内包含一组类，它们被组织在一个单独的命名空间（namespace）下。
        将数据和方法包装进类中并把具体实现隐藏被称作是封装（encapsulation）。其结果就是一个同时带有特征和行为的数据类型。
    * 访问权限修饰符
        取得对成员的访问权的唯一方式是：
            使成员成为 public。那么无论是谁，无论在哪，都可以访问它。
            赋予成员默认包访问权限，不用加任何访问修饰符，然后将其他类放在相同的包内。这样，其他类就可以访问该成员。
            在"复用"这一章你将看到，继承的类既可以访问 public 成员，也可以访问 protected 成员（但不能访问 private 成员）。只有当两个类处于同一个包内，它才可以访问包访问权限的成员。但现在不用担心继承和 protected。
            提供访问器（accessor）和修改器（mutator）方法（有时也称为"get/set" 方法），从而读取和改变值。
        public: 接口访问权限
            当你使用关键字 public，就意味着紧随 public 后声明的成员对于每个人都是可用的，尤其是使用类库的客户端程序员更是如此。
        默认包
            Java 把这样的文件看作是隶属于该目录的默认包中，因此它们为该目录中所有的其他文件都提供了包访问权限。
        private: 你无法访问
            关键字 private 意味着除了包含该成员的类，其他任何类都无法访问这个成员。
        protected: 继承访问权限
            相同包内的其他类可以访问 protected 元素。
            关键字 protected 处理的是继承的概念，通过继承可以利用一个现有的类——我们称之为基类，然后添加新成员到现有类中而不必碰现有类。
            表示“就类的用户而言，这是 private 的。但对于任何继承它的子类或在同一包中的类，它是可访问的。”（protected 也提供了包访问权限）
    * 接口和实现
        访问控制通常被称为隐藏实现（implementation hiding）。
        将数据和方法包装进类中并把具体实现隐藏被称作是封装（encapsulation）。
        出于两个重要的原因，访问控制在数据类型内部划定了边界。
            第一个原因：确立客户端程序员可以使用和不能使用的边界。
                可以在结构中建立自己的内部机制而不必担心客户端程序员偶尔将内部实现作为他们可以使用的接口的一部分。
            第二个原因：将接口与实现分离。
                如果在一组程序中使用接口，而客户端程序员只能向 public 接口发送消息的话，那么就可以自由地修改任何不是 public 的事物（例如包访问权限，protected，或 private 修饰的事物），却不会破坏客户端代码。
    * 类访问权限
        每个编译单元（即每个文件）中只能有一个 public 类。这表示，每个编译单元有一个公共的接口用 public 类表示。该接口可以包含许多支持包访问权限的类。一旦一个编译单元中出现一个以上的 public 类，编译就会报错。
        public 类的名称必须与含有该编译单元的文件名相同，包括大小写。所以对于 Widget 来说，文件名必须是 Widget.java，不能是 widget.java 或 WIDGET.java。再次强调，如果名字不匹配，编译器会报错。
        虽然不是很常见，但是编译单元内没有 public 类也是可能的。这时可以随意命名文件（尽管随意命名会让代码的阅读者和维护者感到困惑）。
        
## * reuse[复用] *
    两种方式来达到这个目的：
        “组合”（Composition），在新类中创建现有类的对象。
        “继承”（Inheritance）,创建现有类类型的新类。继承是面向对象编程（OOP）的重要基础之一。更多功能相关将在多态（Polymorphism）章节中介绍。
    * 组合语法[com/mzl/reuse/SprinklerSystem.java,com/mzl/reuse/Bath.java]
        你仅需要把对象的引用（object references）放置在一个新的类里，这就使用了组合。
        初始化引用有四种方法:
            当对象被定义时。这意味着它们总是在调用构造函数之前初始化。
            在该类的构造函数中。
            在实际使用对象之前。这通常称为延迟初始化。在对象创建开销大且不需要每次都创建对象的情况下，它可以减少开销。
            使用实例初始化。
    * 继承语法
        继承是所有面向对象语言的一个组成部分。
        事实证明，在创建类时总是要继承，因为除非显式地继承其他类，否则就隐式地继承 Java 的标准根类对象（Object）。
        如果其他包中的类继承 Cleanser，则该类只能访问 Cleanser 的公共成员。
        为了允许继承，一般规则是所有字段为私有，所有方法为公共。(受保护成员也允许派生类访问;你以后会知道的。)
        Java的 super 关键字引用了当前类继承的“超类”(基类)。
        继承时，你不受限于使用基类的方法。你还可以像向类添加任何方法一样向派生类添加新方法:只需定义它。
    * 初始化基类
        基类（父类）和派生类（子类）
        Java 自动在派生类构造函数中插入对基类构造函数的调用。
        构造从基类“向外”进行，因此基类在派生类构造函数能够访问它之前进行初始化。
    * 委托[com/mzl/reuse/delegate]
        Java不直接支持的第三种重用关系称为委托。
        这介于继承和组合之间，因为你将一个成员对象放在正在构建的类中(比如组合)，但同时又在新类中公开来自成员对象的所有方法(比如继承)。
        类型：
            A use B
                B类对象在A类中出现，但是是以局部变量或是方法参数的形式出现的。A类中并没有B类的对象作为域。
                一般称这种delegation为临时性的delegation。
            A has B
                B类对象在A类中出现，B类的对象是A类的域之一。B类对象通过A类对象的constructor方法或其它方法从外部输入A类对象。
                有两种情况。
                    1）Association。A类对象和B类对象之间并没有从属关系。
                    2）Aggregation。A类对象由B类聚合而成，但是B类可以脱离A类单独存在。
                一般称这种delegation为永久性的delegation。
            A ispartof B
                B类对象在A类中出现，B类的对象是A类的域之一。B类对象在A类对象内创建。
                B类对象不能脱离A类对象独立存在。
                一般称这种delegation为永久性的delegation。
    * 聚合
    
    * 结合组合与继承
    
    * 组合与继承的选择
        组合和继承都允许在新类中放置子对象（组合是显式的，而继承是隐式的）。
        当你想在新类中包含一个已有类的功能时，使用组合，而非继承。
        如果必须向上转型，那么继承就是必要的，但如果不需要，则要进一步考虑是否该采用继承。
    * final关键字
        final 数据
            一个被 static 和 final 同时修饰的属性只会占用一段不能改变的存储空间。
            基本类型
                对于基本类型，final 使数值恒定不变。
            对象
                对于对象引用，final 使引用恒定不变。
                一旦引用被初始化指向了某个对象，它就不能改为指向其他对象。但是，对象本身是可以修改的，Java 没有提供将任意对象设为常量的方法。
        空白 final
            空白 final 指的是没有初始化值的 final 属性。
            你必须在定义时或在每个构造器中执行 final 变量的赋值操作。这保证了 final 属性在使用前已经被初始化过。
        final 参数
            在参数列表中，将参数声明为 final 意味着在方法中不能改变参数指向的对象或基本变量
        final 方法            
            原因有两个
                第一个原因是给方法上锁，防止子类通过覆写改变方法的行为。这是出于继承的考虑，确保方法的行为不会因继承而改变。
                效率。
            final 和 private
                类中所有的 private 方法都隐式地指定为 final。因为不能访问 private 方法，所以不能覆写它。
                可以给 private 方法添加 final 修饰，但是并不能给方法带来额外的含义。
        final 类
            当说一个类是 final （final 关键字在类定义之前），就意味着它不能被继承。
            由于 final 类禁止继承，类中所有的方法都被隐式地指定为 final，所以没有办法覆写它们。
        final 忠告
    * 类初始化和加载
        记住每个类的编译代码都存在于它自己独立的文件中。该文件只有在使用程序代码时才会被加载。
        一般可以说“类的代码在首次使用时加载“。这通常是指创建类的第一个对象，或者是访问了类的 static 属性或方法。
        构造器也是一个 static 方法尽管它的 static 关键字是隐式的。
        因此，准确地说，一个类当它任意一个 static 成员被访问时，就会被加载。
        首次使用时就是 static 初始化发生时。所有的 static 对象和 static 代码块在加载时按照文本的顺序（在类中定义的顺序）依次初始化。static 变量只被初始化一次。
            
## * polymorphism[多态] *
    多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做。
    封装通过合并特征和行为来创建新的数据类型。
    隐藏实现通过将细节私有化把接口与实现分离。
    而多态是消除类型之间的耦合。
    * 向上转型
        这种把一个对象引用当作它的基类引用的做法称为向上转型，因为继承图中基类一般都位于最上方。
    * 方法调用绑定
        概念：将一个方法调用和一个方法主体关联起来称作绑定。
            前期绑定：若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做前期绑定。
            后期绑定：意味着在运行时根据对象的类型进行绑定，也称为动态绑定或运行时绑定。
        Java 中除了 static 和 final 方法（private 方法也是隐式的 final）外，其他所有方法都是后期绑定。
        如果一个方法是静态(static)的，它的行为就不具有多态性。
        静态的方法只与类关联，与单个的对象无关。
    * 构造器和多态
        尽管构造器不具有多态性（事实上人们会把它看作是隐式声明的静态方法），但是理解构造器在复杂层次结构中运作多态还是非常重要的。
        初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用到。
        对象的构造器调用顺序如下：
            1.基类构造器被调用。这个步骤被递归地重复，这样一来类层次的顶级父类会被最先构造，然后是它的派生类，以此类推，直到最底层的派生类。
            2.按声明顺序初始化成员。
            3.调用派生类构造器的方法体。
        编写构造器有一条良好规范：
            做尽量少的事让对象进入良好状态。
                如果有可能的话，尽量不要调用类中的任何方法。
                在基类的构造器中能安全调用的只有基类的 final 方法（这也适用于可被看作是 final 的 private 方法）。
                这些方法不能被重写，因此不会产生意想不到的结果。你可能无法永远遵循这条规范，但应该朝着它努力。
    * 继承和清理
        在使用组合和继承创建新类时，大部分时候你无需关心清理。子对象通常会留给垃圾收集器处理。
        如果你存在清理问题，那么必须用心地为新类创建一个 dispose() 方法（这里用的是我选择的名称，你可以使用更好的名称）。
        由于继承，如果有其他特殊的清理工作的话，就必须在派生类中重写 dispose() 方法。当重写 dispose() 方法时，记得调用基类的 dispose() 方法，否则基类的清理工作不会发生
    * 使用继承设计
        学习过多态之后，一切看似都可以被继承，因为多态是如此巧妙的工具。这会给设计带来负担。事实上，如果利用已有类创建新类首先选择继承的话，事情会变得莫名的复杂。
        更好的方法是首先选择组合，特别是不知道该使用哪种方法时。
        组合不会强制设计是继承层次结构，而且组合更加灵活，因为可以动态地选择类型（因而选择相应的行为），而继承要求必须在编译时知道确切类型。
    * 替代 vs 扩展
        “is - a"关系：它有着相同的基本接口，纯粹的替代。
        “is - like - a” 关系：它有着相同的基本接口，但还具有需要额外方法实现的其他特性。
    * 向下转型与运行时类型信息
        由于向上转型（在继承层次中向上移动）会丢失具体的类型信息，那么为了重新获取类型信息，就需要在继承层次中向下移动，使用向下转型。
        
## * interfaces[接口]--未理解 *
    接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。
    对于构建具有属性和未实现方法的类来说，抽象类也是重要且必要的工具。你不可能总是使用纯粹的接口。
    * 抽象类和方法
        抽象类，一种介于普通类和接口之间的折中手段。
        创建一个抽象类是为了通过通用接口操纵一系列类。 
        抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。
        创建抽象类和抽象方法是有帮助的，因为它们使得类的抽象性很明确，并能告知用户和编译器使用意图。
        抽象类同时也是一种有用的重构工具，使用它们使得我们很容易地将沿着继承层级结构上移公共方法。
        抽象类和普通类的主要有三点区别：
            1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。
            2）抽象类不能用来创建对象；
            3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。
    * 接口创建
        使用 interface 关键字创建接口。
        接口只提供形式，通常来说没有实现，尽管在某些受限制的情况下可以有实现。
        区别：
            Java 8之前
                只允许抽象方法，没有提供任何实现。
            Java 8
                允许接口包含默认方法和静态方法。
        接口同样可以包含属性，这些属性被隐式指明为 static 和 final。
        来自接口中的方法必须被定义为 public。否则，它们只有包访问权限，这样在继承时，它们的可访问权限就被降低了，这是 Java 编译器所不允许的。
        - 默认方法
            Java 8 为关键字 default 增加了一个新的用途（之前只用于 switch 语句和注解中）。
            当在接口中使用它时，任何实现接口却没有定义方法的时候可以使用 default 创建的方法体。
            默认方法，实现类没有实现它，不受影响，而且实现类还可以调用默认方法
    * 多继承
        多继承意味着一个类可能从多个父类型中继承特征和特性。
        Java 8，Java 通过默认方法具有了某种多继承的特性。
        属性仍然只会来自单个基类或抽象类，不会存在状态的多继承。
        实现多个接口时，若方法名，参数都一致，则实现时需要覆写该方法，否则会报错
    * 接口中的静态方法
        Java 8 允许在接口中添加静态方法。这么做能恰当地把工具功能置于接口中，从而操作接口，或者成为通用的工具
    * 抽象类和接口
        尤其是在 Java 8 引入 default 方法之后，选择用抽象类还是用接口变得更加令人困惑。下表做了明确的区分：
        
| 特性 | 接口 | 抽象类 |
| ------ | ------ |------ |
| 组合 | 新类可以组合多个接口 |只能继承单一抽象类 |
| 状态 | 不能包含属性（除了静态属性，不支持对象状态） |可以包含属性，非抽象方法可能引用这些属性 |
| 默认方法和抽象方法 | 不需要在子类中实现默认方法。默认方法可以引用其他接口的方法 |必须在子类中实现抽象方法 |
| 构造器 | 没有构造器 |可以有构造器 |     
| 可见性 | 隐式 public |可以是 protected 或友元 |     
        
        有一条实际经验：尽可能地抽象。因此，更倾向使用接口而不是抽象类。只有当必要时才使用抽象类。除非必须使用，否则不要用接口和抽象类。大多数时候，普通类已经做得很好，如果不行的话，再移动到接口或抽象类中。
    * 完全解耦       
    * 多接口结合
    * 结合接口时的命名冲突
        覆写、实现和重载令人不快地搅和在一起带来了困难。同时，重载方法仅根据返回类型是区分不了的。
        当打算组合接口时，在不同的接口中使用相同的方法名通常会造成代码可读性的混乱，尽量避免这种情况。
    
## * innerclasses[内部类] *
    当生成一个内部类的对象时，此对象与制造它的外部对象（enclosing object）之间就有了一种联系，所以它能访问其外部对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外部类的所有元素的访问权。
    > 使用 .this 和 .new
        如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 this（.this）。
        使用.new语法直接创建内部类
    在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗地连接到建它的外部类对象上。但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。
    > 内部类与向上转型
    > 内部类方法和作用域
        在一个方法里面或者在任意的作用域内定义内部类
        这么做有两个理由：
            1.如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。
            2.你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。
    > 嵌套类
        普通的内部类对象隐式地保存了一个引用，指向创建它的外部类对象。
        如果不需要内部类对象与其外部类对象之间有联系，那么可以将内部类声明为 static，这通常称为嵌套类。
        嵌套类意味着：
            1.要创建嵌套类的对象，并不需要其外部类的对象。
            2.不能从嵌套类的对象中访问非静态的外部类对象。
        >> 接口内部的类
            如果你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的嵌套类会显得很方便。
    > 为什么需要内部类
        一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外部类的对象。所以可以认为内部类提供了某种进入其外部类的窗口。
        每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
        如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承
        >> 如果不需要解决“多重继承”的问题，那么自然可以用别的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他一些特性：
           1.内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的信息相互独立。
           2.在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。 稍后就会展示一个这样的例子。
           3.创建内部类对象的时刻并不依赖于外部类对象的创建
           4.内部类并没有令人迷惑的"is-a”关系，它就是一个独立的实体。
        >> 闭包与回调
            闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。
            通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外部类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外部类对象的引用，在此作用域内，内部类有权操作所有的成员，包括 private 成员。
            在 Java 8 之前，内部类是实现闭包的唯一方式。 Java 8 中，我们可以使用 lambda 表达式来实现闭包行为。
        >> 内部类与控制框架
            应用程序框架（application framework）就是被设计用以解决某类特定问题的一个类或一组类。
            控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件的系统被称作事件驱动系统。应用程序设计中常见的问题之一是图形用户接口（GUI），它几乎完全是事件驱动的系统。
            内部类允许：
                1.控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表示解决问题所必需的各种不同的 action()。
                2.内部类能够很容易地访问外部类的任意成员，所以可以避免这种实现变得笨拙。如果没有这种能力，代码将变得令人讨厌，以至于你肯定会选择别的方法。  
            
## * collections[集合] *
    java.util 库提供了一套相当完整的集合类（collection classes）来解决这个问题，其中基本的类型有 List 、 Set 、 Queue 和 Map。
    集合还有一些其它特性。
        例如， Set 对于每个值都只保存一个对象， Map 是一个关联数组，允许将某些对象与其他对象关联起来。
    Java集合类都可以自动地调整自己的大小。因此，与数组不同，在编程时，可以将任意数量的对象放置在集合中，而不用关心集合应该有多大。
    > 泛型和类型安全的集合
        当指定了某个类型为泛型参数时，并不仅限于只能将确切类型的对象放入集合中。向上转型也可以像作用于其他类型一样作用于泛型：
        Java集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口：
            集合（Collection） ：一个独立元素的序列，这些元素都服从一条或多条规则。
                List 必须以插入的顺序保存元素
                Set 不能包含重复元素
                Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。
            映射（Map） ： 一组成对的“键值对”对象，允许使用键来查找值。 
                ArrayList 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 
                map 允许我们使用一个对象来查找另一个对象，它也被称作关联数组（associative array），因为它将对象和其它对象关联在一起；或者称作字典（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 Map 是强大的编程工具。
        ArrayList 和 LinkedList 都是 List 的类型，从输出中可以看出，它们都按插入顺序保存元素。
        HashSet 使用相当复杂的方法存储元素。现在只需要知道，这种技术是检索元素的最快方法，因此，存储顺序看上去没有什么意义（通常只关心某事物是否是 Set 的成员，而存储顺序并不重要）。如果存储顺序很重要，则可以使用 TreeSet ，它将按比较结果的升序保存对象 或 LinkedHashSet ，它按照被添加的先后顺序保存对象。
        HashMap 中的顺序不是插入顺序，因为 HashMap 实现使用了非常快速的算法来控制顺序。 TreeMap 通过比较结果的升序来保存键， LinkedHashMap 在保持 HashMap 查找速度的同时按键的插入顺序保存键。
    > 列表List
        有两种类型的 List ：
            基本的 ArrayList ，擅长随机访问元素，但在 List 中间插入和删除元素时速度较慢。
            LinkedList ，它通过代价较低的在 List 中间进行的插入和删除操作，提供了优化的顺序访问。 LinkedList 对于随机访问来说相对较慢，但它具有比 ArrayList 更大的特征集。
    > 迭代器Iterators
        一段通用代码，它不知道或不关心它正在使用什么类型的集合，因此它可以用于不同类型的集合，那么如何才能不重写代码就可以应用于不同类型的集合？
        迭代器（也是一种设计模式）的概念实现了这种抽象。
        Java 的 Iterator 只能单向移动。这个 Iterator 只能用来：
            使用 iterator() 方法要求集合返回一个 Iterator。 Iterator 将准备好返回序列中的第一个元素。
            使用 next() 方法获得序列中的下一个元素。
            使用 hasNext() 方法检查序列中是否还有元素。
            使用 remove() 方法将迭代器最近返回的那个元素删除。
        >> ListIterator
            ListIterator 是一个更强大的 Iterator 子类型，它只能由各种 List 类生成。 Iterator 只能向前移动，而 ListIterator 可以双向移动。
            它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 set() 方法替换它访问过的最近一个元素。
            可以通过调用 listIterator() 方法来生成指向 List 开头处的 ListIterator ，还可以通过调用 listIterator(n) 创建一个一开始就指向列表索引号为 n 的元素处的 ListIterator 。
    > 链表LinkedList
        LinkedList 也像 ArrayList 一样实现了基本的 List 接口，但它在 List 中间执行插入和删除操作时比 ArrayList 更高效。然而,它在随机访问操作效率方面却要逊色一些。
        LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque） 。
            getFirst() 和 element() 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 List 为空，则抛出 NoSuchElementException 异常。 peek() 方法与这两个方法只是稍有差异，它在列表为空时返回 null 。
            removeFirst() 和 remove() 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 NoSuchElementException 异常。 poll() 稍有差异，它在列表为空时返回 null 。
            addFirst() 在列表的开头插入一个元素。
            offer() 与 add() 和 addLast() 相同。 它们都在列表的尾部（末尾）添加一个元素。
            removeLast() 删除并返回列表的最后一个元素。
    > 堆栈Stack
        堆栈是“后进先出”（LIFO）集合。它有时被称为叠加栈（pushdown stack），因为最后“压入”（push）栈的元素，第一个被“弹出”（pop）栈。
    > 集合Set
        Set 不保存重复的元素。
        HashSet
            输出没有可辨别的顺序。这是因为出于对速度的追求， HashSet 使用了散列。
            TreeSet 将元素存储在红-黑树数据结构中，而 HashSet 使用散列函数。 
            LinkedHashSet 因为查询速度的原因也使用了散列，但是看起来使用了链表来维护元素的插入顺序。
        TreeSet
            排序是按字典顺序（lexicographically）完成的，因此大写和小写字母位于不同的组中。
            如果想按字母顺序（alphabetically）对其进行排序，可以向 TreeSet 构造器传入 String.CASE_INSENSITIVE_ORDER 比较器（比较器是一个建立排序顺序的对象）：
    > 映射Map
        Map 与数组和其他的 Collection 一样，可以轻松地扩展到多个维度，只需要创建一个值为 Map 的 Map（这些 Map 的值可以是其他集合，甚至是其他 Map）。
        Map 可以返回由其键组成的 Set ，由其值组成的 Collection ，或者其键值对的 Set 。 keySet() 方法生成由在 petPeople 中的所有键组成的 Set ，它在 for-in 语句中被用来遍历该 Map 。
    > 队列Queue
        队列是一个典型的“先进先出”（FIFO）集合。
        队列在并发编程中尤为重要，因为它们可以安全地将对象从一个任务传输到另一个任务。
        LinkedList 实现了 Queue 接口，并且提供了一些方法以支持队列行为，因此 LinkedList 可以用作 Queue 的一种实现。 通过将 LinkedList 向上转换为 Queue 。
        offer() 是与 Queue 相关的方法之一，它在允许的情况下，在队列的尾部插入一个元素，或者返回 false 。
        peek() 和 element() 都返回队头元素而不删除它，但是如果队列为空，则 element() 抛出 NoSuchElementException ，而 peek() 返回 null 。 
        poll() 和 remove()* 都删除并返回队头元素，但如果队列为空，poll() 返回 null ，而 remove() 抛出 NoSuchElementException 。
        >> 优先级队列PriorityQueue
            当在 PriorityQueue 上调用 offer() 方法来插入一个对象时，该对象会在队列中被排序。
            默认的排序使用队列中对象的自然顺序（natural order），但是可以通过提供自己的 Comparator 来修改这个顺序。
            PriorityQueue 是允许重复的，最小的值具有最高的优先级（如果是 String ，空格也可以算作值，并且比字母的优先级高）。
    > 集合与迭代器
        Collection 是所有序列集合共有的根接口。
    > 适配器方法惯用法
    > Java 提供了许多保存对象的方法：
        1.数组将数字索引与对象相关联。它保存类型明确的对象，因此在查找对象时不必对结果做类型转换。它可以是多维的，可以保存基本类型的数据。虽然可以在运行时创建数组，但是一旦创建数组，就无法更改数组的大小。
        2.Collection 保存单一的元素，而 Map 包含相关联的键值对。使用 Java 泛型，可以指定集合中保存的对象的类型，因此不能将错误类型的对象放入集合中，并且在从集合中获取元素时，不必进行类型转换。各种 Collection 和各种 Map 都可以在你向其中添加更多的元素时，自动调整其尺寸大小。集合不能保存基本类型，但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。
        3.像数组一样， List 也将数字索引与对象相关联，因此，数组和 List 都是有序集合。
        4.如果要执行大量的随机访问，则使用 ArrayList ，如果要经常从表中间插入或删除元素，则应该使用 LinkedList 。
        5.队列和堆栈的行为是通过 LinkedList 提供的。
        6.Map 是一种将对象（而非数字）与对象相关联的设计。 HashMap 专为快速访问而设计，而 TreeMap 保持键始终处于排序状态，所以没有 HashMap 快。 LinkedHashMap 按插入顺序保存其元素，但使用散列提供快速访问的能力。
        7.Set 不接受重复元素。 HashSet 提供最快的查询速度，而 TreeSet 保持元素处于排序状态。 LinkedHashSet 按插入顺序保存其元素，但使用散列提供快速访问的能力。
        8.不要在新代码中使用遗留类 Vector ，Hashtable 和 Stack 。
    > 简单集合分类
        实际上只有四个基本的集合组件： Map ， List ， Set 和 Queue。
        除 TreeSet 之外的所有 Set 都具有与 Collection 完全相同的接口。
        List 和 Collection 存在着明显的不同，尽管 List 所要求的方法都在 Collection 中。
        另一方面，在 Queue 接口中的方法是独立的，在创建具有 Queue 功能的实现时，不需要使用 Collection 方法。
        最后， Map 和 Collection 之间唯一的交集是 Map 可以使用 entrySet() 和 values() 方法来产生 Collection 。
      
## * functional [函数式编程] *
    通过合并现有代码来生成新功能而不是从头开始编写所有内容，我们可以更快地获得更可靠的代码。
    OO（object oriented，面向对象）是抽象数据，FP（functional programming，函数式编程）是抽象行为。
    如果函数永远不会修改现有值但只生成新值，则不会对内存产生争用，这是纯函数式语言的定义。
    因此，经常提出纯函数式语言作为并行编程的解决方案（还有其他可行的解决方案）。
    > 新旧对比
    > Lambda表达式
        Lambda 表达式是使用最小可能语法编写的函数定义：
            1.Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。
            2.Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。
        递归
            递归函数是一个自我调用的函数。可以编写递归的 Lambda 表达式，但需要注意：递归方法必须是实例变量或静态变量，否则会出现编译时错误。
        方法引用
            Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟 :: ，然后跟方法名称。
        未绑定的方法引用
            未绑定的方法引用是指没有关联对象的普通（非静态）方法。 使用未绑定的引用之前，我们必须先提供对象：
    函数式接口
        Lambda 表达式包含类型推导（编译器会自动推导出类型信息，避免了程序员显式地声明）。
        以下是基本命名准则：
            如果只处理对象而非基本类型，名称则为 Function，Consumer，Predicate 等。参数类型通过泛型添加。
            如果接收的参数是基本类型，则由名称的第一部分表示，如 LongConsumer，DoubleFunction，IntPredicate 等，但基本 Supplier 类型例外。
            如果返回值为基本类型，则用 To 表示，如 ToLongFunction <T> 和 IntToLongFunction。
            如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 UnaryOperator，两个参数使用 BinaryOperator。
            如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。
            如果接收的两个参数类型不同，则名称中有一个 Bi。
    多参数函数式接口
        java.util.functional 中的接口是有限的。比如有了 BiFunction，但它不能变化。 如果需要三参数函数的接口怎么办？ 其实这些接口非常简单，很容易查看 Java 库源代码并自行创建。
    缺少基本类型的函数
    高阶函数
        
        
## [流式编程]
    stream接口继承自BaseStream，其中IntStream, LongStream, DoubleStream对应三种基本类型（int, long, double，注意不是包装类型），Stream对应所有剩余类型的stream视图。
    为不同数据类型设置不同stream接口，可以1.提高性能，2.增加特定接口函数。
    虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：
        无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。
        为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。
        惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。
        可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。
    对stream的操作分为为两类，中间操作(intermediate operations)和结束操作(terminal operations)，二者特点是：
        中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。
        结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。
    区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为stream的大都是中间操作，否则是结束操作。
    Stream接口的部分常见方法：
        操作类型	    接口方法
        中间操作	    concat() distinct() filter() flatMap() limit() map() peek()
                    skip() sorted() parallel() sequential() unordered()
        结束操作	    allMatch() anyMatch() collect() count() findAny() findFirst()
                    forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()
    
    
## [异常]

## [代码校验]

## [文件]

## [字符串]

## * typeinfo[类型信息] *

## [泛型]

## [数组]

## [枚举]

## [注解]

## [并发编程]

## [设计模式]

## * regularexpression [正则表达式]*

## [jvm命令]
    aload 负载
        运作方式：加载本地变量的引用
        格式：aload index
        形式：aload = 25 (0x19)
        描述：
            该指数是一个无符号字节,必须被索引到当前帧的局部变量数组(§2.6)。局部变量的指数必须包含一个参考。objectref在局部变量指数推到操作数堆栈。
        笔记：
            aload指令不能用于加载一个类型的值returnAddress从一个局部变量到操作数堆栈。这种不对称的astore指令(§astore)是故意的。
            可以使用aload操作码结合宽指令(§宽)来访问一个本地变量使用两字节无符号索引。
    aload_<n>  
        运作方式：加载本地变量的引用
        格式：aload_<n>
        形式：
            aload_0 = 42 (0x2a)
            aload_1 = 43 (0x2b)
            aload_2 = 44 (0x2c)
            aload_3 = 45 (0x2d)
        描述：
            < n >必须被索引到当前帧的局部变量数组(§2.6)。在< n >局部变量必须包含一个参考。局部变量在< n >中的objectref推到操作数堆栈。
        笔记:
            一个aload_ < n >指令不能用于加载一个类型的值returnAddress从一个局部变量到操作数堆栈。这种不对称与相应astore_ < n >指令(§astore_ < n >)是故意的。
            每个aload_ < n >指令一样aload指数< n >,除了操作数< n >是隐式的。
    iload 加载
        运作方式：int从局部变量 加载
        格式：
            iload
            index
        形式：iload = 21（0x15）
        描述：
            该指数是一个必须是一个指数到当前帧（的局部变量阵列的无符号字节§2.6）。索引处的局部变量必须包含int。的值在局部变量的索引被压入操作数栈。
        笔记：
            所述ILOAD操作码可结合使用与宽 指令（§宽），使用两字节的无符号索引来访问的本地变量。
    iload_<n>
        运作方式：int从局部变量 加载
        格式：
            iload_<n>
        形式：
            iload_0 = 26（0x1a）
            iload_1 = 27（0x1b）
            iload_2 = 28（0x1c）
            iload_3 = 29（0x1d）
        描述：
            必须是当前帧的局部变量数组的索引（第2.6节）的局部变量必须包含一个int。的值在局部变量的被压入操作数栈。
        笔记：
            每个iload_<n>指令一样iload指数,除了操作数是隐式的。
    iconst 
        运作方式：推int常数
        格式：iconst_ <i>
        形式：
            iconst_m1 = 2（0x2）
            iconst_0 = 3（0x3）
            iconst_1 = 4（0x4）
            iconst_2 = 5（0x5）
            iconst_3 = 6（0x6）
            iconst_4 = 7（0x7）
            iconst_5 = 8（0x8）
        描述：
            将int常数（-1、0、1、2、3、4或5）推入操作数堆栈。
        笔记：
            这个家庭每个人的指令相当于bipush 的各自的价值,除了操作数是隐式的。
    putfield 
        运作方式：在对象中设置字段
        格式：
            putfield
            indexbyte1
            indexbyte2
        形式：putfield = 181（0xB5执行）
        描述：
        
    invokespecial 特殊调用
        运作方式：调用实例方法；对超类，私有和实例初始化方法调用的特殊处理
        格式：
            invokespecial
            indexbyte1
            indexbyte2
        形式：
            invokespecial = 183（0xb7）
        
## Java8 新增了非常多的特性，我们主要讨论以下几个：
    
    Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。
    
    方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
    
    默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。
    
    新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。
    
    Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。
    
    Date Time API − 加强对日期与时间的处理。
    
    Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。
    
    Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。
