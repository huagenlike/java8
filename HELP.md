# Getting Started

## objects[万物皆对象]
    通常除了前面提到的“特殊”数据类型 boolean、 char、 byte、 short、 int、 long、 float 和 double。通常来说，传递对象就意味者传递对象的引用。
    
    * 创建一个 String 引用
        String s;
    * 创建一个引用的同时进行初始化
        String s = "asdf";
    * 创建一个新的对象实例，通常我们使用new操作符来创建一个新对象
        String s = new String("asdf");
    * 数据存储
        寄存器（Registers）最快的存储区域，位于 CPU 内部 ^2。
        栈内存（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。
        堆内存（Heap）这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。
        常量存储（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。
        非 RAM 存储（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。
    * 基本类型默认值
        boolean	    false
        char	    \u0000 (null)
        byte	    (byte) 0
        short	    (short) 0
        int	        0
        long	    0L
        float	    0.0f
        double	    0.0d
        
        这些默认值仅在 Java 初始化类的时候才会被赋予。
    * 高精度数值
        在 Java 中有两种类型的数据可用于高精度的计算。它们是 BigInteger 和 BigDecimal。尽管它们大致可以划归为“包装类型”，但是它们并没有对应的基本类型。
            BigInteger 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。 
            BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的货币计算。
    * 数组的存储
        数组使用前需要被初始化，并且不能访问数组长度以外的数据。
        当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为 null 。在使用该数组之前，我们必须为每个引用指定一个对象 。如果我们尝试使用为 null 的引用，则会在运行时报错。
        创建基本类型的数组。编译器通过将该数组的内存全部置零来保证初始化。
        
## operators[运算符]
    * 优先级
        乘法和除法在加法和减法之前完成。
    * 赋值
        运算符的赋值是由符号 = 完成的。它代表着获取 = 右边的值并赋给左边的变量。
        右边可以是任何常量、变量或者可产生一个返回值的表达式。但左边必须是一个明确的、已命名的变量。
        基本类型的赋值都是直接的，而不像对象，赋予的只是其内存的引用。举个例子，a = b 
            如果 b 是基本类型，那么赋值操作会将 b 的值复制一份给变量 a， 此后若 a 的值发生改变是不会影响到 b 的。
            如果是为对象赋值，那么结果就不一样了。对一个对象进行操作时，我们实际上操作的是它的引用。所以我们将右边的对象赋予给左边时，赋予的只是该对象的引用。此时，两者指向的堆中的对象还是同一个。
    * 一元加减运算符
            一元减号可以得到数据的负值。一元加号的作用相反，不过它唯一能影响的就是把较小的数值类型自动转换为 int 类型。
    * 递增和递减
        “前递增”表示 ++(++a) 运算符位于变量或表达式的前面；会先执行递增/减运算，再返回值。
        “后递增”表示 ++(a++) 运算符位于变量的后面；会先返回值，再执行递增/减运算
    * 测试对象等价
        数值的比较可以用 == 或 != 进行
        Integer 比较
            用 == 或 != 进行
                1.内部维护着一个 IntegerCache 的缓存，默认缓存范围是 [-128, 127]，在这个范围内是直接返回数值
                2.[-128, 127] 范围外，可使用 Integer.intValue() 在比对
            用 equals
                [-128, 127] 范围之外
        equals() 的默认行为是比较对象的引用而非具体内容（即引用地址）。因此，除非你在新类中覆写 equals() 方法，否则我们将获取不到想要的结果。
    * 短路
        && 或 ||
            表达式走到 false 后，不会再继续往下走；返回 false
        & 或 | 
            表达式走到 false 后，会再继续往下走；返回 false
    * 字面值常量
        Long 型数值，结尾使用大写 L 或小写 l 皆可（不推荐使用 l，因为容易与阿拉伯数值 1 混淆）。
        float 浮点数，大写 F 或小写 f 表示 。
        double 双精度，大写 D 或小写 d 表示 。
        十六进制（以 16 为基数），适用于所有整型数据类型，由前导 0x 或 0X 表示，后跟 0-9 或 a-f （大写或小写）。
    * 位运算符
        与、或、异或、非 运算
        与【&】
            若两个输入位都是 1，运算结果是 1，否则结果是 0。
        或【|】
            若两个输入位里至少有一个是 1，运算结果是 1；只有在两个输入位都是 0 的情况下，运算结果才是 0。
        异或【^】
            若两个输入位的某一个是 1，另一个不是 1，运算结果才是 1。
        非【~】
            属于一元运算符；它只对一个自变量进行操作（其他所有运算符都是二元运算符）。
            按位非运算后结果与输入位相反。
            例如输入 0，则输出 1；输入 1，则输出 0。
        &=，|= 和 ^= 都是合法的（由于 ~ 是一元运算符，所以不可与 = 联合使用）。
        - 移位运算符
            高位代表符号：0 表示正，1 表示负。
            概念：移位运算符面向的运算对象也是二进制的“位”。它们只能用于处理整数类型（基本类型的一种）。
            分类
                左移位运算符 << 能将其左边的运算对象向左移动右侧指定的位数（在低位补 0）。
                右移位运算符 >> 则相反。右移位运算符有“正”、“负”值：若值为正，则在高位插入 0；若值为负，则在高位插入 1。
                “不分正负”的右移位运算符（>>>），它使用了“零扩展”（zero extension）：无论正负，都在高位插入 0。
            移位可以与等号 <<= 或 >>= 或 >>>= 组合使用。
    * 三元运算符
        布尔表达式 ? 值 1 : 值 2
        若表达式计算为 true，则返回结果 值 1 ；如果表达式的计算为 false，则返回结果 值 2。
    * 字符串运算符
        一个空字符串 "" 跟着一个基本类型的数据。这样可以隐式地将其转换为字符串。
    * 类型转换
        在适当的时候，Java 会将一种数据类型自动转换成另一种。
        要执行强制转换，需要将所需的数据类型放在任何值左侧的括号内，如下所示：long lng2 = (long)200;  
        向下转换（将容量较大的数据类型转换成容量较小的类型）
            必须显式地类型转换。
            可能会发生信息丢失的危险。
        向上转型  
            不必进行显式的类型转换，因为较大类型的数据肯定能容纳较小类型的数据，不会造成任何信息的丢失。
    * 截断和舍入
        从 float 和 double 转换为整数值时，小数位将被截断。
        若你想对结果进行四舍五入，可以使用 java.lang.Math 的 round() 方法
    * 类型提升
        如果我们对小于 int 的基本数据类型（即 char、byte 或 short）执行任何算术或按位操作，这些值会在执行操作之前类型提升为 int，并且结果值的类型为 int。
        若想重新使用较小的类型，必须使用强制转换（由于重新分配回一个较小的类型，结果可能会丢失精度）。
        通常，表达式中最大的数据类型是决定表达式结果的数据类型。float 型和 double 型相乘，结果是 double 型的；int 和 long 相加，结果是 long 型。
    
## control[控制流]
    * if-else
        if-else 语句是控制程序执行流程最基本的形式。 其中 else 是可选的，因此可以有两种形式的 if。
    * 迭代语句
        while，do-while 和 for 用来控制循环语句。只有控制循环的布尔表达式计算结果为 false，循环语句才会停止。
        while
            执行语句会在每一次循环前，判断布尔表达式返回值是否为 true。
        do-while 
            即使条件表达式返回结果为 false， do-while 语句也至少会执行一次。
        for
            该循环在第一次迭代之前执行初始化。随后，它会执行布尔表达式，并在每次迭代结束时，进行某种形式的步进。
        switch
            根据整数表达式的值，switch 语句可以从一系列代码中选出一段去执行。
            Java 7 增加了在字符串上 switch 的用法。
            若省略 break， 会继续执行后面的 case 语句的代码，直到遇到一个 break 为止。
    * return
        关键字包括 return，break，continue 和跳转到带标签语句的方法，类似于其他语言中的 goto。
    * break 和 continue
        break 表示跳出当前循环体。
        continue 表示停止本次循环，开始下一次循环。
        
        demo[com/mzl/control/LabeledFor.java]
        简单的一个 continue 会退回最内层循环的开头（顶部），并继续执行。
        带有标签的 continue 会到达标签的位置，并重新进入紧接在那个标签后面的循环。
        break 会中断当前循环，并移离当前标签的末尾。
        带标签的 break 会中断当前循环，并移离由那个标签指示的循环的末尾。
        
## housekeeping[初始化和清理]
    * 利用构造器保证初始化
        分类：
            无参构造器
            有参构造器
        在 Java 中，对象的创建与初始化是统一的概念，二者不可分割。
        在 Java 中，类的设计者通过构造器保证每个对象的初始化。
        构造器没有返回值，它是一种特殊的方法。
        如果一个类有构造器，那么 Java 会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化。
    * 方法重载
        区分重载方法
            每个被重载的方法必须有独一无二的参数列表。
        重载与基本类型
            基本类型可以自动从较小的类型转型为较大的类型。
            如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换，如果你不做的话，编译器就会报错。
        返回值的重载
            1.可以根据返回值进项判定调用的哪个方法
            2.如果只调用了方法，而不接收返回值，Java 编译器就不知道你想调用哪个方法，所以你不能根据返回值类型区分重载的方法。
    * 垃圾回收器:
        创建的对象不是通过 new 来分配内存的，而垃圾回收器只知道如何释放用 new 创建的对象的内存。为了处理这种情况，Java 允许在类中定义一个名为 finalize() 的方法。
        对象可能不被垃圾回收。
        垃圾回收不等同于析构。
        垃圾回收只与内存有关。
    * 垃圾回收器如何工作
        垃圾回收器通过重新排列对象，实现了一种高速的、有无限空间可分配的堆模型。
        引用计数
            每个对象中含有一个引用计数器，每当有引用指向该对象时，引用计数加 1。当引用离开作用域或被置为 null 时，引用计数减 1。
        停止-复制（stop-and-copy）
        标记-清扫（mark-and-sweep）
            对一般用途而言，"标记-清扫"方式速度相当慢，但是当你知道程序只会产生少量垃圾甚至不产生垃圾时，它的速度就很快了。
        类(class)要被使用必须经过装载，连接，初始化这样的过程。
            连接阶段又可以分为三个子步骤：验证、准备和解析。
                1. 验证就是要确保java类型数据格式 的正确性，并适于JVM使用。
                2. 准备阶段，JVM为静态变量分配内存空间，并设置默认值，注意，这里是设置默认值，比如说int型的变量会被赋予默认值0 。在这个阶段，JVM可能还会为一些数据结构分配内存，目的 是提高运行程序的性能，比如说方法表。
                3. 解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用。这个阶段可以被推迟到初始化之后，当程序运行的过程中真正使用某个符号引用的时候 再去解析它。
    * 静态数据的初始化
        无论创建多少个对象，静态数据都只占用一份存储区域
        static 关键字不能应用于局部变量，所以只能作用于属性（字段、域）
        如果在定义时进行初始化，那么静态变量看起来就跟非静态变量一样。
        静态初始化只有在必要时刻才会进行（类会在首次被“主动使用”时执行初始化，为类（静态）变量赋予正确的初始值）
        主动使用包括：
            1. 创建类的实例
            2. 调用类的静态方法
            3. 使用类的非常量静态字段
            4. 调用Java API中的某些反射方法
            5. 初始化某个类的子类
            6. 含有main()方法的类启动时
        初始化一个类包括两个步骤：
            1、 如果类存在直接父类的话，且直接父类还没有被初始化，则先初始化其直接父类
            2、 如果类存在一个初始化方法，就执行此方法
        java调用某个类的静态方法时不会执行构造方法，只有在实例化时才会调用构造方法
    * 数组初始化
        数组是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。
        所有的数组（无论是对象数组还是基本类型数组）都有一个固定成员 length，告诉你这个数组有多少个元素，你不能对其修改。
        数组元素中的基本数据类型值会自动初始化为默认值（对于数字和字符是 0；对于布尔型是 false）
    * 枚举类型
    
## hiding[封装]
    * 访问修饰符（access specifier）
        从“最大权限”到“最小权限”依次是：public，protected，包访问权限（package access）（没有关键字）和 private。
    * 包的概念
        包内包含一组类，它们被组织在一个单独的命名空间（namespace）下。
        将数据和方法包装进类中并把具体实现隐藏被称作是封装（encapsulation）。其结果就是一个同时带有特征和行为的数据类型。
    * 访问权限修饰符
        取得对成员的访问权的唯一方式是：
            使成员成为 public。那么无论是谁，无论在哪，都可以访问它。
            赋予成员默认包访问权限，不用加任何访问修饰符，然后将其他类放在相同的包内。这样，其他类就可以访问该成员。
            在"复用"这一章你将看到，继承的类既可以访问 public 成员，也可以访问 protected 成员（但不能访问 private 成员）。只有当两个类处于同一个包内，它才可以访问包访问权限的成员。但现在不用担心继承和 protected。
            提供访问器（accessor）和修改器（mutator）方法（有时也称为"get/set" 方法），从而读取和改变值。
        public: 接口访问权限
            当你使用关键字 public，就意味着紧随 public 后声明的成员对于每个人都是可用的，尤其是使用类库的客户端程序员更是如此。
        默认包
            Java 把这样的文件看作是隶属于该目录的默认包中，因此它们为该目录中所有的其他文件都提供了包访问权限。
        private: 你无法访问
            关键字 private 意味着除了包含该成员的类，其他任何类都无法访问这个成员。
        protected: 继承访问权限
            相同包内的其他类可以访问 protected 元素。
            关键字 protected 处理的是继承的概念，通过继承可以利用一个现有的类——我们称之为基类，然后添加新成员到现有类中而不必碰现有类。
            表示“就类的用户而言，这是 private 的。但对于任何继承它的子类或在同一包中的类，它是可访问的。”（protected 也提供了包访问权限）
    * 接口和实现
        访问控制通常被称为隐藏实现（implementation hiding）。
        将数据和方法包装进类中并把具体实现隐藏被称作是封装（encapsulation）。
        出于两个重要的原因，访问控制在数据类型内部划定了边界。
            第一个原因：确立客户端程序员可以使用和不能使用的边界。
                可以在结构中建立自己的内部机制而不必担心客户端程序员偶尔将内部实现作为他们可以使用的接口的一部分。
            第二个原因：将接口与实现分离。
                如果在一组程序中使用接口，而客户端程序员只能向 public 接口发送消息的话，那么就可以自由地修改任何不是 public 的事物（例如包访问权限，protected，或 private 修饰的事物），却不会破坏客户端代码。
    * 类访问权限
        每个编译单元（即每个文件）中只能有一个 public 类。这表示，每个编译单元有一个公共的接口用 public 类表示。该接口可以包含许多支持包访问权限的类。一旦一个编译单元中出现一个以上的 public 类，编译就会报错。
        public 类的名称必须与含有该编译单元的文件名相同，包括大小写。所以对于 Widget 来说，文件名必须是 Widget.java，不能是 widget.java 或 WIDGET.java。再次强调，如果名字不匹配，编译器会报错。
        虽然不是很常见，但是编译单元内没有 public 类也是可能的。这时可以随意命名文件（尽管随意命名会让代码的阅读者和维护者感到困惑）。
        
## reuse[复用]
    两种方式来达到这个目的：
        “组合”（Composition），在新类中创建现有类的对象。
        “继承”（Inheritance）,创建现有类类型的新类。继承是面向对象编程（OOP）的重要基础之一。更多功能相关将在多态（Polymorphism）章节中介绍。
    * 组合语法[com/mzl/reuse/SprinklerSystem.java,com/mzl/reuse/Bath.java]
        你仅需要把对象的引用（object references）放置在一个新的类里，这就使用了组合。
        初始化引用有四种方法:
            当对象被定义时。这意味着它们总是在调用构造函数之前初始化。
            在该类的构造函数中。
            在实际使用对象之前。这通常称为延迟初始化。在对象创建开销大且不需要每次都创建对象的情况下，它可以减少开销。
            使用实例初始化。
    * 继承语法
        继承是所有面向对象语言的一个组成部分。
        事实证明，在创建类时总是要继承，因为除非显式地继承其他类，否则就隐式地继承 Java 的标准根类对象（Object）。
        如果其他包中的类继承 Cleanser，则该类只能访问 Cleanser 的公共成员。
        为了允许继承，一般规则是所有字段为私有，所有方法为公共。(受保护成员也允许派生类访问;你以后会知道的。)
        Java的 super 关键字引用了当前类继承的“超类”(基类)。
        继承时，你不受限于使用基类的方法。你还可以像向类添加任何方法一样向派生类添加新方法:只需定义它。
    * 初始化基类
        基类（父类）和派生类（子类）
        Java 自动在派生类构造函数中插入对基类构造函数的调用。
        构造从基类“向外”进行，因此基类在派生类构造函数能够访问它之前进行初始化。
    * 委托[com/mzl/reuse/delegate]
        Java不直接支持的第三种重用关系称为委托。
        这介于继承和组合之间，因为你将一个成员对象放在正在构建的类中(比如组合)，但同时又在新类中公开来自成员对象的所有方法(比如继承)。
        类型：
            A use B
                B类对象在A类中出现，但是是以局部变量或是方法参数的形式出现的。A类中并没有B类的对象作为域。
                一般称这种delegation为临时性的delegation。
            A has B
                B类对象在A类中出现，B类的对象是A类的域之一。B类对象通过A类对象的constructor方法或其它方法从外部输入A类对象。
                有两种情况。
                    1）Association。A类对象和B类对象之间并没有从属关系。
                    2）Aggregation。A类对象由B类聚合而成，但是B类可以脱离A类单独存在。
                一般称这种delegation为永久性的delegation。
            A ispartof B
                B类对象在A类中出现，B类的对象是A类的域之一。B类对象在A类对象内创建。
                B类对象不能脱离A类对象独立存在。
                一般称这种delegation为永久性的delegation。
    * 聚合
    
    * 结合组合与继承
    
    * 组合与继承的选择
        组合和继承都允许在新类中放置子对象（组合是显式的，而继承是隐式的）。
        当你想在新类中包含一个已有类的功能时，使用组合，而非继承。
        如果必须向上转型，那么继承就是必要的，但如果不需要，则要进一步考虑是否该采用继承。
    * final关键字
        final 数据
            一个被 static 和 final 同时修饰的属性只会占用一段不能改变的存储空间。
            基本类型
                对于基本类型，final 使数值恒定不变。
            对象
                对于对象引用，final 使引用恒定不变。
                一旦引用被初始化指向了某个对象，它就不能改为指向其他对象。但是，对象本身是可以修改的，Java 没有提供将任意对象设为常量的方法。
        空白 final
            空白 final 指的是没有初始化值的 final 属性。
            你必须在定义时或在每个构造器中执行 final 变量的赋值操作。这保证了 final 属性在使用前已经被初始化过。
        final 参数
            在参数列表中，将参数声明为 final 意味着在方法中不能改变参数指向的对象或基本变量
        final 方法            
            原因有两个
                第一个原因是给方法上锁，防止子类通过覆写改变方法的行为。这是出于继承的考虑，确保方法的行为不会因继承而改变。
                效率。
            final 和 private
                类中所有的 private 方法都隐式地指定为 final。因为不能访问 private 方法，所以不能覆写它。
                可以给 private 方法添加 final 修饰，但是并不能给方法带来额外的含义。
        final 类
            当说一个类是 final （final 关键字在类定义之前），就意味着它不能被继承。
            由于 final 类禁止继承，类中所有的方法都被隐式地指定为 final，所以没有办法覆写它们。
        final 忠告
    * 类初始化和加载
        记住每个类的编译代码都存在于它自己独立的文件中。该文件只有在使用程序代码时才会被加载。
        一般可以说“类的代码在首次使用时加载“。这通常是指创建类的第一个对象，或者是访问了类的 static 属性或方法。
        构造器也是一个 static 方法尽管它的 static 关键字是隐式的。
        因此，准确地说，一个类当它任意一个 static 成员被访问时，就会被加载。
        首次使用时就是 static 初始化发生时。所有的 static 对象和 static 代码块在加载时按照文本的顺序（在类中定义的顺序）依次初始化。static 变量只被初始化一次。
            
## polymorphism[多态]
    多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做。
    封装通过合并特征和行为来创建新的数据类型。
    隐藏实现通过将细节私有化把接口与实现分离。
    而多态是消除类型之间的耦合。
    * 向上转型
        这种把一个对象引用当作它的基类引用的做法称为向上转型，因为继承图中基类一般都位于最上方。
    * 方法调用绑定
        概念：将一个方法调用和一个方法主体关联起来称作绑定。
            前期绑定：若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做前期绑定。
            后期绑定：意味着在运行时根据对象的类型进行绑定，也称为动态绑定或运行时绑定。
        Java 中除了 static 和 final 方法（private 方法也是隐式的 final）外，其他所有方法都是后期绑定。
    
## [接口]

## [内部类]

## [集合]

## [函数式编程]

## [流式编程]

## [异常]

## [代码校验]

## [文件]

## [字符串]

## [类型信息]

## [泛型]

## [数组]

## [枚举]

## [注解]

## [并发编程]

## [设计模式]

Java8 新增了非常多的特性，我们主要讨论以下几个：
    
    Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。
    
    方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
    
    默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。
    
    新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。
    
    Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。
    
    Date Time API − 加强对日期与时间的处理。
    
    Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。
    
    Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。